Приближенный двоичный поиск

Реализуйте алгоритм приближенного бинарного поиска.

Входные данные
В первой строке входных данных содержатся числа N и K (0 < N, K  < 100001). Во второй строке задаются N чисел первого массива, отсортированного по неубыванию, а в третьей строке – K чисел второго массива. Каждое число в обоих массивах по модулю не превосходит 2*10
99.

Выходные данные
Для каждого из K чисел выведите в отдельную строку число из первого массива, наиболее близкое к данному. Если таких несколько, выведите меньшее из них.

Sample Input:
5 5
1 3 5 7 9
2 4 8 1 6

Sample Output:
1
3
7
1
5

Напишите программу. Тестируется через stdin → stdout
Верно решили 178 учащихся
Из всех попыток 38% верных


# ruby
def findPosition(num_list, number, first, last)
    if last >= first
        middle = first + (last - first) / 2
        if num_list[middle] == number
            return middle # eqv
        elsif num_list[middle] < number
            return findPosition(num_list, number, middle + 1, last)
        else
            return findPosition(num_list, number, first, middle - 1)    
        end
    else
        return last # ~left
    end
end        
        
n, k = gets.chomp.split(' ').map{ |j| j.to_i }[1..]  
a = gets.chomp.split(' ').map{ |j| j.to_i }       
b = gets.chomp.split(' ').map{ |j| j.to_i }
    
b.each do |d|  
    pos = findPosition(a, d, 0, a.size - 1) # eqv or ~left
    if pos < a.size - 1 # ~right
        pos1 = pos + 1
    else
        pos1 = pos
    end

    if (a[pos]-d).abs <= (a[pos1]-d).abs # eqv or ~left or ~right
        puts a[pos]
    else
        puts a[pos1]        
    end
end


# python
from bisect import bisect_right

_, nums, keys = ([*map(int, row.split())] for row in open(0).read().split('\n'))
for key in keys:
    idx = min(bisect_right(nums, key), len(nums) - 1)
    print(min(nums[idx - 1], nums[idx], key=lambda x: (abs(x - key), x)))



# JS
var stdin = process.openStdin();
function bifind(arr, a){
    let [x,y] = [0,arr.length-1];
    if (+arr[y] <= a) return +arr[y];
    if (+arr[x] >= a) return +arr[x];
    while (y-x !== 1) {
        let t = x + Math.floor((y-x)/2);
        if (+arr[t]===a) return +arr[t]
        else if (+arr[t]>a) y=t
        else x=t;
    }
    if (Math.abs(a - +arr[x]) - Math.abs(a - +arr[y])  > 0 )
    return +arr[y]
    else return +arr[x];
}
stdin.addListener("data", function(d) {
    let str = d.toString().split('\n');
    let item_find = str[2].split(' ');
    str = str[1].split(' ');
    for (let i of item_find) 
        console.log(bifind(str, +i)); 
  });


# C#
using System;

public class MainClass
{
    public static void Main()
    {
        string non=Console. ReadLine();
        int[] n=Array.ConvertAll(Console. ReadLine(). Split(),int.Parse);
        int[] k=Array.ConvertAll(Console. ReadLine().Split(),int.Parse);
        
        foreach(int i in k)
        {    
        int min=Math.Abs(i-n[0]);
        int number=n[0];       
            foreach(int j in n)
            {
                int tmp=Math.Abs(i-j);
                if(tmp<min)
                {
                min=tmp;
                number=j;
                }
            }
            Console.WriteLine(number);
        }               
    }
}



# java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        int k = Integer.parseInt(input.nextLine().trim());

        int[] one = new int[n];
        int[] two = new int[k];

        for (int a = 0; a < n; a++) one[a] = input.nextInt();
        for (int b = 0; b < k; b++) two[b] = input.nextInt();

        for (int e = 0; e < k; e++) {
            System.out.println(one[approximatelyBinarySearch(one, two[e])]);
        }
    }

    public static int approximatelyBinarySearch(int[] array, int number) {
        int start = 0, end = array.length - 1, middlePoint;
        int difference = Integer.MAX_VALUE, index = Integer.MAX_VALUE;

        while(start <= end) {
            middlePoint = (start + end) / 2;

            if(array[middlePoint] - number == 0) {
                return middlePoint;
            }
            else if(array[middlePoint] - number < 0) {
                if(Math.abs(array[middlePoint] - number) == difference) {
                    if(middlePoint < index) index = middlePoint;
                }
                if(Math.abs(array[middlePoint] - number) < difference) {
                    difference = Math.abs(array[middlePoint] - number);
                    index = middlePoint;
                }
                start = middlePoint + 1;
            }
            else {
                if(Math.abs(array[middlePoint] - number) < difference) {
                    difference = Math.abs(array[middlePoint] - number);
                    index = middlePoint;
                }
                end = middlePoint - 1;
            }
        }

        return index;
    }
}


# C++
#include <iostream>
using namespace std;
long int approx_bin_search(long int a[], int dim, int idx_left, int idx_right, long int el) {
    long int res;
    if(el >= a[idx_right]) {
        res = a[idx_right];
    } else if (el <= a[idx_left]) {
        res = a[idx_left];
    } else {
        // a[idx_left] < el < a[idx_right]
        int idx, delta;
        long int dist;
        delta = idx_right - idx_left;
        if(delta == 0) {
            res = a[idx_right];
        } else if(delta == 1) {
            if(el - a[idx_left] <= a[idx_right] - el) {
                res = a[idx_left];
            } else {
                res = a[idx_right];
            }
        } else if(delta > 1) {
            idx = idx_left + delta / 2;
            dist = el - a[idx];
            if(dist == 0) {
                res = a[idx];
            } else if(dist > 0) {
                idx_left = idx;
                res = approx_bin_search(a, dim, idx_left, idx_right, el);
            } else if(dist < 0) {
                idx_right = idx;
                res = approx_bin_search(a, dim, idx_left, idx_right, el);
            }
        }
    }
    return res;
}
int main() {
    // put your code here
    const int dim_max = 100001;
    int n, k;
    long int sorted[dim_max] = {0};
    long int arr[dim_max] = {0};
    cin >> n >> k;
    for(int i = 0; i < n; ++i) {
        cin >> sorted[i];
    }
    for(int i = 0; i < k; ++i) {
        cin >> arr[i];
        cout << approx_bin_search(sorted, n, 0, n - 1, arr[i]) << endl;
    }
    return 0;
}



