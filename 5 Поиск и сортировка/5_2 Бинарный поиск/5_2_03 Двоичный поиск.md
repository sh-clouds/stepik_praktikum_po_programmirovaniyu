Двоичный поиск

Реализуйте алгоритм бинарного поиска.

Входные данные
В первой строке входных данных содержатся натуральные числа N и K (0 < N, K < 100000). Во второй строке задаются N элементов первого массива, отсортированного по возрастанию, а в третьей строке – K элементов второго массива. Элементы обоих массивов - целые числа, каждое из которых по модулю не превосходит 109

Выходные данные
Требуется для каждого из K чисел вывести в отдельную строку "YES", если это число встречается в первом массиве, и "NO" в противном случае.

Sample Input:
10 5
1 2 3 4 5 6 7 8 9 10
-2 0 4 9 12

Sample Output:
NO
NO
YES
YES
NO

Напишите программу. Тестируется через stdin → stdout
Верно решили 273 учащихся
Из всех попыток 70% верных


# ruby
def findPosition(num_list, number, first, last)
    if last >= first
        middle = first + (last - first) / 2
        if num_list[middle] == number
            return middle # eqv
        elsif num_list[middle] < number
            return findPosition(num_list, number, middle + 1, last)
        else
            return findPosition(num_list, number, first, middle - 1)    
        end
    else
        return -1 # no eqv
    end
end        
        
n, k = gets.chomp.split(' ').map{ |j| j.to_i }[1..]  
a = gets.chomp.split(' ').map{ |j| j.to_i }       
b = gets.chomp.split(' ').map{ |j| j.to_i }
    
b.each do |d|  
    print findPosition(a, d, 0, a.size - 1) > -1 ? "YES\n" : "NO\n"
end


# python
from bisect import bisect_left

def contains(l, elem):
    index = bisect_left(l, elem)
    if index < len(l):
        return l[index] == elem
    return False

lst = [[int(i) for i in el.split()] for el in  open(0).read().split('\n')]
print(*[('NO','YES')[contains(lst[1], el)] for el in lst[2]], sep ='\n')



# JS
var stdin = process.openStdin();
function bifind(arr, a){
    let [x,y] = [0,arr.length-1];
    if (+arr[y] < a) return -1;
    if (+arr[x] > a) return -1;
    if (+arr[x] === a) return x;
    if (+arr[y] === a) return y;
    while (y-x !== 1) {
        let t = x + Math.floor((y-x)/2);
        if (+arr[t]===a) return t
        else if (+arr[t]>a) y=t
        else x=t;
   }
    return -1;
}
stdin.addListener("data", function(d) {
    let str = d.toString().split('\n');
    let item_find = str[2].split(' ');
    str = str[1].split(' ');
    for (let i of item_find) 
        console.log( (bifind(str, +i)+1) ? 'YES' : 'NO' ); 
  });



# C#
using System;

Console.ReadLine();
int[] sorted = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);
int[] usual = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);

Array.ForEach(
    usual,
    x => Console.WriteLine(Array.BinarySearch(sorted, x) < 0 ? "NO" : "YES")
);


# java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        int k = Integer.parseInt(input.nextLine().trim());

        int[] one = new int[n];
        int[] two = new int[k];

        for (int a = 0; a < n; a++) one[a] = input.nextInt();
        for (int b = 0; b < k; b++) two[b] = input.nextInt();

        for (int e = 0; e < k; e++) System.out.println(binarySearch(one, two[e]) > -1 ? "YES" : "NO");
    }

    public static int binarySearch(int[] array, int number) {
        int start = 0, end = array.length - 1, middlePoint;

        while (start <= end) {
            middlePoint = (start + end) / 2;

            if (array[middlePoint] == number) {
                return middlePoint;
            }
            else if (array[middlePoint] < number) {
                start = middlePoint + 1;
            }
            else {
                end = middlePoint - 1;
            }
        }

        return -1;
    }
}



# C
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

size_t input_n();
int8_t init_array(int64_t** arr, size_t N);
void input_array(int64_t** arr, size_t N);
void echo_array(int64_t** arr, size_t N);
int8_t binary_search(int64_t** arr, size_t N, int64_t X);

int main() {
    size_t N = input_n();
    size_t K = input_n();
    int64_t* array_1 = NULL;
    int64_t* array_2 = NULL;
    if (N && K && init_array(&array_1, N) && init_array(&array_2, K)) {
        input_array(&array_1, N);
        input_array(&array_2, K);
        for (size_t i = 0; i < K; i++)
            printf("%s\n", binary_search(&array_1, N, array_2[i]) ? "YES" : "NO");
        free(array_2);
        free(array_1);
    }
    return 0;
}

int8_t binary_search(int64_t** arr, size_t N, int64_t X) {
    size_t left = 0;
    size_t right = N - 1;
    size_t i = 0;
    int8_t result = 0;
    while (left <= right) {
        i = (left + right) / 2;
        if ((*arr)[i] == X) {
            result = 1;
            break;
        } else if (X < (*arr)[i]) {
            if (i == 0) break; // иначе size_t поломается)
            right = i - 1;
        } else if (X > (*arr)[i]) {
            left = i + 1;
        }
    }
    return result;
}

void echo_array(int64_t** arr, size_t N) {
    for (size_t i = 0; i < N; i++)
        printf("%"PRId64"%s", (*arr)[i], i + 1 == N ? "" : " ");
}

void input_array(int64_t** arr, size_t N) {
    for (size_t i = 0; i < N; i++)
            scanf("%"SCNd64, &((*arr)[i]));
}

int8_t init_array(int64_t** arr, size_t N) {
    int8_t result = 0;
    *arr = malloc(N * sizeof(int64_t));
    if (*arr != NULL) result = 1;
    return result;
}

size_t input_n() {
    size_t N = 0;
    int64_t num = 0;
    N = (scanf("%"SCNd64, &num) == 1 && num > 0) ? num : 0;
    return N;
}



# C++
#include <iostream>
#include <vector>
using namespace std;

bool Binary_Search(vector<int> arr, int x) {
    while (arr.size() > 1) {
        int size = arr.size();
        if (arr[(size - 2) / 2] == x) return true;
        if (arr[(size - 2) / 2] > x) arr.erase(arr.begin() + (size - 2) / 2, arr.end());
        if (arr[(size - 2) / 2] < x) arr.erase(arr.begin(), arr.begin() + (size - 2) / 2 + 1);
    }
    return arr[0] == x;
}

void sort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        int j = i - 1;
        while (j >= 0 && arr[j] > arr[j + 1]) {
            swap(arr[j], arr[j + 1]);
            j--;
         }
    }
}

int main() {

    int N, K; cin >> N >> K;
    vector<int> arr1(N);
    for (int i = 0; i < N; i++) cin >> arr1[i];
    sort(arr1);
    
    vector<int> arr2(K);
    for (int i = 0; i < K; i++) cin >> arr2[i];
    
    for (int i = 0; i < K; i++) cout << (Binary_Search(arr1, arr2[i]) ? "YES\n" : "NO\n");
    return 0;
}


