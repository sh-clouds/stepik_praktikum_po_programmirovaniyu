Левый и правый двоичный поиск

Дано два списка чисел, числа в первом списке упорядочены по неубыванию. Для каждого числа из второго списка определите номер первого и последнего появления этого числа в первом списке.

Входные данные

В первой строке входных данных записано два числа N и M (1 < N, M < 20000). Во второй строке записано N упорядоченных по неубыванию целых чисел — элементы первого списка. В третьей строке записаны M целых неотрицательных чисел - элементы второго списка. Все числа в списках - целые 32-битные знаковые.

Выходные данные

Программа должна вывести M строчек. Для каждого числа из второго списка нужно вывести номер его первого и последнего вхождения в первый список. Нумерация начинается с единицы. Если число не входит в первый список, нужно вывести одно число 0.

Sample Input:

10 5
1 1 3 3 5 7 9 18 18 57
57 3 9 1 179
Sample Output:

10 10
3 4
7 7
1 2
0


# ruby     
def LBinSearch(array, target)
    l = 0              # указатель на левую границу
    r = array.size     # указатель на правую границу

    finded = false

    while l < r
        m = (l + r) / 2
        if array[m] == target 
            finded = true
        end
        
        if array[m] >= target
            r = m
        else
            l = m + 1
        end        
    end
    
    if (finded) 
        return l
    else 
        return -1      
    end
end                
                
def RBinSearch(array, target)
    l = 0                # указатель на левую границу
    r = array.size-1     # указатель на правую границу

    while l < r
        m = (l + r + 1) / 2
        if array[m] <= target
            l = m
        else
            r = m - 1
        end
    end
    return l
end    

n, m = gets.chomp.split(' ').map{ |j| j.to_i }[1..]  
a = gets.chomp.split(' ').map{ |j| j.to_i }       
b = gets.chomp.split(' ').map{ |j| j.to_i }

b.each do |d|  
    pos = LBinSearch(a, d)
    if pos > -1
        print "#{pos+1} "
        print RBinSearch(a, d) + 1
    else
        print 0
    end    
    print "\n"
end



# python
from bisect import bisect_left, bisect_right

_, nums, keys = ([*map(int, row.split())] for row in open(0).read().split('\n'))
for key in keys:
    left = bisect_left(nums, key)
    right = bisect_right(nums, key)
    print(*(left + 1, right) if left != right else [0])


# JS
var stdin = process.openStdin();
function bifind(arr, a){
    let [x,y] = [0,arr.length-1];
    if (+arr[y] < a) return -1;
    if (+arr[x] > a) return -1;
    if (+arr[x] === a) return x;
    if (+arr[y] === a) return y;
    while (y-x !== 1) {
        let t = x + Math.floor((y-x)/2);
        if (+arr[t]===a) return t
        else if (+arr[t]>a) y=t
        else x=t;
   }
    return -1;
}

function findAll (arr, a) {
    let i = bifind(arr, a);
    if ( i === -1 ) return 0
    else {
        while (i+1<arr.length && arr[i] === arr[i+1]) i++;
        let result = ' '+(i+1);
        while (i-1>=0 && arr[i-1] === arr[i]) i--;
        return (i+1)+result;    
    }
}
stdin.addListener("data", function(d) {
    let str = d.toString().split('\n');
    let item_find = str[2].split(' ');
    str = str[1].split(' ');
    for (let i of item_find) 
        console.log(findAll(str, +i)); 
  });

  

# C#
using System;

public class MainClass
{
    static void Main(string[] args)
    {
        Console.ReadLine();
        int[] array = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);
        int[] target = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);

        foreach(var item in target)
        {
            int first = LBinSearch(array, item);
            if (first == -1) Console.WriteLine(0);
            else
            {
                int last = RBinSearch(array, item);
                Console.WriteLine($"{first + 1} {last + 1}");
            }
        }
    }

    
    static int LBinSearch(int[] array, int target)
    {
        int l = 0; // указатель на левую границу
        int r = array.Length; // указатель на правую границу

        bool finded = false;

        while (l < r)
        {
            int m = (l + r) / 2;
            if (array[m] == target) finded = true;
            if (array[m] >= target)
                r = m;
            else
                l = m + 1;
        }
        if (finded) return l;
        else return -1;
    }

    static int RBinSearch(int[] array, int target)
    {
        int l = 0; // указатель на левую границу
        int r = array.Length-1; // указатель на правую границу

        while (l < r)
        {
            int m = (l + r + 1) / 2;
            if (array[m] <= target)
                l = m;
            else
                r = m - 1;
        }
        return l;
    }
}


# java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        int m = Integer.parseInt(input.nextLine().trim());

        int[] one = new int[n];
        int[] two = new int[m];

        for (int a = 0; a < n; a++) one[a] = input.nextInt();
        for (int b = 0; b < m; b++) two[b] = input.nextInt();

        for (int e = 0; e < m; e++) {
            int theFirst = getTheFirst(one, two[e]);
            int theLast = getTheLast(one, two[e]);

            if (theFirst > -1 && theLast > -1) System.out.printf("%d %d%n", theFirst + 1, theLast + 1);
            else System.out.println(0);
        }
    }

    private static int binarySearch(int[] array, int number) {
        int start = 0, end = array.length - 1, middlePoint;

        while (start <= end) {
            middlePoint = (start + end) / 2;

            if (array[middlePoint] == number) {
                return middlePoint;
            }
            else if (array[middlePoint] < number) {
                start = middlePoint + 1;
            }
            else {
                end = middlePoint - 1;
            }
        }

        return -1;
    }

    private static int getTheFirst(int[] array, int number) {
        int index = -1, current;
        int[] arr = Arrays.copyOf(array, array.length);

        while ((current = binarySearch(arr, number)) > -1) {
            index = current;
            arr = Arrays.copyOf(arr, index);
        }

        return index;
    }

    private static int getTheLast(int[] array, int number) {
        int index = -1, current, length = array.length, difference = 0;
        int[] arr = Arrays.copyOf(array, length);

        while ((current = binarySearch(arr, number)) > -1) {
            index = current;
            difference += index + 1;
            length = length - index - 1;
            int[] currentArr = new int[length];
            System.arraycopy(arr, index + 1, currentArr, 0, currentArr.length);
            arr = Arrays.copyOf(currentArr, length);
        }

        return difference - 1;
    }
}



# C
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

size_t input_n();
int8_t init_array(int64_t** arr, size_t N);
void input_array(int64_t** arr, size_t N);
void echo_array(int64_t** arr, size_t N);
int8_t binary_search_wo(int64_t** arr, size_t N, int64_t X);  // with output

int main() {
    size_t N = input_n();
    size_t K = input_n();
    int64_t* array_1 = NULL;
    int64_t* array_2 = NULL;
    if (N && K && init_array(&array_1, N) && init_array(&array_2, K)) {
        input_array(&array_1, N);
        input_array(&array_2, K);
        for (size_t i = 0; i < K; i++) {
            binary_search_wo(&array_1, N, array_2[i]);
            if (i + 1 != K) printf("\n");
        }
        free(array_2);
        free(array_1);
    }
    return 0;
}

int8_t binary_search_wo(int64_t** arr, size_t N, int64_t X) {
    size_t left = 0;
    size_t right = N - 1;
    size_t i = 0;
    int8_t result = 0;
    while (left <= right) {
        i = (left + right) / 2;
        if ((*arr)[i] == X) {
            // номер = индекс + 1
            result = 1;
            while (i && (*arr)[i - 1] == X) i--;
            printf("%zu", i + 1);
            while ((i < N) && (*arr)[i + 1] == X) i++;
            printf(" %zu", i + 1);
            break;
        } else if (X < (*arr)[i]) {
            if (i == 0) break; // иначе size_t поломается)
            right = i - 1;
        } else if (X > (*arr)[i]) {
            left = i + 1;
        }
    }
    if (!result) printf("0");
    return result;
}

void echo_array(int64_t** arr, size_t N) {
    for (size_t i = 0; i < N; i++)
        printf("%"PRId64"%s", (*arr)[i], i + 1 == N ? "" : " ");
}

void input_array(int64_t** arr, size_t N) {
    for (size_t i = 0; i < N; i++)
            scanf("%"SCNd64, &((*arr)[i]));
}

int8_t init_array(int64_t** arr, size_t N) {
    int8_t result = 0;
    *arr = malloc(N * sizeof(int64_t));
    if (*arr != NULL) result = 1;
    return result;
}

size_t input_n() {
    size_t N = 0;
    int64_t num = 0;
    N = (scanf("%"SCNd64, &num) == 1 && num > 0) ? num : 0;
    return N;
}   


