Пузырьковая сортировка: количество обменов

Ввод и вывод данных производятся через стандартные потоки ввода-вывода.

Определите, сколько обменов сделает алгоритм пузырьковой сортировки по возрастанию для данного массива.

Входные данные
На первой строке дано число N (1 ≤ N ≤ 1000) – количество элементов в массиве. На второй строке – сам массив. Гарантируется, что все элементы массива различны и не превышают по модулю 109.

Выходные данные
Выведите одно число – количество обменов пузырьковой сортировки.

Sample Input:
5
1 2 3 4 5

Sample Output:
0


# ruby
n = gets.to_i
a = gets.chomp.split(' ').map{ |j| j.to_i }
cnt = 0

1.upto(a.size-1) do |j|
    isSorted = true
    0.upto(n-j-1) do |i|  
        if a[i] > a[i + 1]
            a[i], a[i + 1] = a[i + 1], a[i]
            cnt += 1
            isSorted = false   
        end
    end    
    if (isSorted)
        break
    end        
end

print cnt


# python
input()
a = [int(i) for i in input().split()]
n = len(a)
count = 0
for i in range(n - 1):
    flag = True
    for j in range(n - i - 1):
        if a[j] > a[j + 1]:
            count += 1
            a[j], a[j + 1] = a[j + 1], a[j]
            flag = False
    if flag:
        break
print(count)


# JS
var stdin = process.openStdin();

stdin.addListener("data", function(d) {
    let str = d.toString().split('\n');
    str = str[1].split(' ');
    let result = 0;
    for (let i=0; i<str.length-1; i++) 
        for (j=0; j<str.length-i-1; j++)
        if (+str[j] > +str[j+1]) {
            [str[j], str[j+1]] = [str[j+1], str[j]];
            result++
        }
    console.log(result); 
  });

  
# C#
using System;

public class MainClass
{
    public static void Main()
    {
      int n=int.Parse(Console.ReadLine());
        int[] arr=Array.ConvertAll(Console.ReadLine(). Split(),int.Parse);
        int count=0;
      for(int j=1;j<n;j++)
      {
       for(int i=0;i<n-j;i++)
       {
           if(arr[i]>arr[i+1])
           {
           (arr[i],arr[i+1])=(arr[i+1],arr[i]);
           count++;
           }
       }
       }
       Console. WriteLine(count);
    }
}


# C
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

size_t input_n();
int8_t init_arr(int16_t** arr, size_t n);
void echo_arr(int16_t** arr, size_t n);
size_t sort_bubble_se(int16_t** arr, size_t n);

int main() {
    size_t n = input_n();
    int16_t* array = NULL;
    if (n > 0 && init_arr(&array, n)) {
        printf("%zu", sort_bubble_se(&array, n));
        //echo_arr(&array, n);
        free(array);
    }
    return 0;
}

size_t sort_bubble_se(int16_t** arr, size_t n) {
    size_t counter = 0;
    for (size_t i = 0; i < n - 1; i++) {
        for (size_t j = 0; j < n - 1 - i; j++) {
            if ((*arr)[j] > (*arr)[j + 1]) {
                int16_t swap = (*arr)[j];
                (*arr)[j] = (*arr)[j + 1];
                (*arr)[j + 1] = swap;
                counter++;
            }
        }
    }
    return counter;
}

void echo_arr(int16_t** arr, size_t n) {
    for (size_t i = 0; i < n; i++)
        printf("%"PRId16"%s", (*arr)[i], (i + 1 != n) ? " " : "");
}

int8_t init_arr(int16_t** arr, size_t n) {
    int8_t res = 0;
    *arr = malloc(n * sizeof(int16_t));
    if (*arr != NULL) {
        res = 1;
        for (size_t i = 0; i < n; i++)
            scanf("%"SCNd16, &((*arr)[i]));
    }
    return res;
}

size_t input_n() {
    size_t n = 0;
    scanf("%zu", &n);
    return n;
}


# C++
#include <iostream>

int main() {
    int n, cnt = 0;
    std::cin >> n;
    int arr[n];
    for (int i = 0; i < n; i++) {
        std::cin >> arr[i];
    }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] > arr[j]) {
                int t = arr[i];
                arr[i] = arr[j];
                arr[j] = t;
                cnt++;
            }
        }
    }
    std::cout << cnt << "\n";
    return 0;
}


