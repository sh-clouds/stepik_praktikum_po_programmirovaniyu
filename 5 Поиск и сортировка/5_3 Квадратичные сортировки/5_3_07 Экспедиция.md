Экспедиция

Месклиниты собрались в экспедицию на край света. У них есть корабль, состоящий из N × M плотиков, связанных между собой. У каждого плотика есть своя грузоподъемность, а у каждого месклинита – своя масса. На каждом плотике может находиться не более одного месклинита. Если грузоподъемность выбранного плотика меньше массы месклинита, то бедный месклинит утонет при посадке.

Руководитель экспедиции продумывает рассадку по плотикам. Помогите ему определить, какому максимальному количеству месклинитов удастся отправиться в путь.

Входные данные
В первой строке даны числа N и M (1 ≤ N, M ≤ 40). В каждой из последующих N строк содержится по M чисел, обозначающих грузоподъемность соответствующего плотика. В (N+2)-ой строке находится число K (1 ≤ K ≤ 2000) – количество месклинитов. В (N+3)-ей строке содержатся K чисел, i-ое из которых – масса i-ого месклинита. Все массы месклинитов и грузоподъемности плотиков – натуральные числа, не превышающие 109.

Выходные данные
Требуется вывести одно число – максимально возможное количество участников экспедиции.

Sample Input:
3 2
5 10
7 5
5 5
6
9 5 3 5 12 10

Sample Output:
4

Напишите программу. Тестируется через stdin → stdout
Верно решили 105 учащихся
Из всех попыток 45% верных


# ruby
n,m = gets.chomp.split(' ').map{ |j| j.to_i }
a = []
0.upto(n-1) do |i|
   a1 = gets.chomp.split(' ').map{ |j| j.to_i }
   a1.each do |j| 
       a.push(j) 
   end    
end
nb = gets.to_i
b = gets.chomp.split(' ').map{ |j| j.to_i }
cnt = 0

a = a.sort.reverse
b = b.sort.reverse

b.each do |i|
   if a.size < 1 then break end
   if i <= a[0]
       cnt += 1
       a.delete_at(0) 
   end    
end

print cnt


# python
_, *rafts, _, mass = ([*map(int, row.split())] for row in open(0).read().split('\n'))
rafts, mass, count = sorted(sum(rafts, [])), sorted(mass), 0
while rafts and mass:
    w, r = mass.pop(), max(rafts)
    if w <= r:
        rafts.remove(r)
        count += 1
print(count)


# JS
var stdin = process.openStdin();

stdin.addListener("data", function(d) {
    let str = d.toString().split('\n');
    let mass = str[str.length-1].split(' ');
    let plots = [];
    for (let i=1; i<str.length-2; i++) {
        let a = str[i].split(' ');
        plots.push(...a);
    }
    mass.sort((a, b) => b-a);
    plots.sort((a, b) => b-a);
    
    let [result, index] = [0, 0];
    for (let plot of plots ) {
        while (index<mass.length && +plot < +mass[index]) index++;
        if (index >= mass.length) break
        else {
            result++;       
            index++;
        }
    }
    console.log(result);
  });


# C#
using System;
using System.Linq;
using System.Collections.Generic;

public class MainClass
{
    public static void Main()
    {
        int[] nm=Array.ConvertAll(Console. ReadLine().Split(), int.Parse);
        var plotMas=new List<int>();
        for(int i=0;i<nm[0];i++)
        {
             plotMas.AddRange
             (Array.ConvertAll (Console.ReadLine().Split(),int.Parse));
        }
        int k=int.Parse(Console.ReadLine());
        var miskMas= new List<int> (Array.ConvertAll(Console. ReadLine().Split(),int.Parse));
        int count=0;
        
        plotMas.Sort();
        miskMas.Sort();        
        
        foreach(int mPlot in plotMas)
        {
         for(int nMisk=0;nMisk<k; nMisk++)
            {
                if(miskMas[nMisk]<=mPlot)
                {
                  count++;    
                                                       miskMas.RemoveAt(nMisk);
                    k--;
                    break;                    
                }
            }
        }
        Console.WriteLine(count);        
    }
}


# java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int[] data = Arrays.stream(input.nextLine().split("\\s+")).mapToInt(Integer::parseInt).toArray();

        List<Ship> ships = new ArrayList<>();

        for(int a = 0; a < data[0]; a++) {
            List<Integer> loads = Arrays
                    .stream(input.nextLine().split("\\s+"))
                    .map(Integer::parseInt)
                    .collect(Collectors.toList());

            List<Seat> seats = new ArrayList<>();

            for(int lCap : loads) {
                seats.add(new Seat(lCap));
            }

            ships.add(new Ship(seats));
        }

        int number = Integer.parseInt(input.nextLine());
        int counter = 0;

        List<Integer> mesklinites = Arrays
                .stream(input.nextLine().split("\\s+"))
                .map(Integer::parseInt)
                .collect(Collectors.toList());

        doBubbleSortInDescendingOrder(mesklinites);

        for(int e = 0; e < number; e++) {
            for(Ship ship : ships) {
                boolean found = false;
                for(int s = 0; s < ship.getPassengerSeats().size(); s++) {
                    if(ship.getPassengerSeats().get(s).getReserved().equals(Reserved.NOT_RESERVED)) {
                        if(ship.getPassengerSeats().get(s).getLoadCapacity() >= mesklinites.get(e)) {
                            ship.getPassengerSeats().get(s).setReserved(Reserved.RESERVED);
                            ++counter;
                            found = true;
                            break;
                        }
                    }
                }
                if(found) break;
            }
        }

        System.out.println(counter);
    }

    private static List<Integer> doBubbleSortInDescendingOrder(List<Integer> list) {
        for(int f = 0; f < list.size() - 1; f++) {
            for(int g = 0; g < list.size() - 1 - f; g++) {
                if (list.get(g) < list.get(g + 1)) {
                    int temporary = list.get(g);
                    list.set(g, list.get(g + 1));
                    list.set(g + 1, temporary);
                }
            }
        }
        return list;
    }
}

class Ship {
    private List<Seat> passengerSeats;

    public Ship(List<Seat> passengerSeats) {
        this.passengerSeats = passengerSeats;
    }

    public List<Seat> getPassengerSeats() {
        return passengerSeats;
    }
}

class Seat {
    private int loadCapacity;
    private Reserved reserved = Reserved.NOT_RESERVED;

    public Seat(int loadCapacity) {
        this.loadCapacity = loadCapacity;
    }

    public int getLoadCapacity() {
        return loadCapacity;
    }

    public Reserved getReserved() {
        return reserved;
    }

    public void setReserved(Reserved reserved) {
        this.reserved = reserved;
    }
}

enum Reserved {
    RESERVED, NOT_RESERVED;
}


# C
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>

size_t input_n();
int8_t init_arr(int64_t** ARR, size_t N);
void input_arr(int64_t** ARR, size_t N);
int8_t clone_arr(int64_t** ARRIN, int64_t** ARROUT, size_t N);
int8_t get_rafts(int64_t** ARR, size_t* N);
int8_t get_mesklinites(int64_t** ARR, size_t* N);
size_t prepare_expedition(int64_t** ARRraf, size_t Nraf, int64_t** ARRmes, size_t Nmes);
void sort_arr(int64_t** ARR, size_t N);
    
int main() {
    size_t R, M, X;
    int64_t* rafts = NULL;
    int64_t* mesklinites = NULL;
    if (get_rafts(&rafts, &R) && get_mesklinites(&mesklinites, &M)) {
        X = prepare_expedition(&rafts, R, &mesklinites, M);
        printf("%zu", X);
        free(mesklinites);
        free(rafts);
    }
    return 0;
}

void sort_arr(int64_t** ARR, size_t N) {
    for (size_t i = 0; i < N - 1; i++)
        for (size_t j = 0; j < N - 1 - i; j++)
            if ((*ARR)[j] > (*ARR)[j + 1]) {
                int64_t swap = (*ARR)[j];
                (*ARR)[j] = (*ARR)[j + 1];
                (*ARR)[j + 1] = swap;
            }
}
    
size_t prepare_expedition(int64_t** ARRraf, size_t Nraf, int64_t** ARRmes, size_t Nmes) {
    size_t members = 0;
    size_t sraf = Nraf, smes = Nmes;
    int64_t* sarrraf = NULL;
    int64_t* sarrmes = NULL;
    if (!clone_arr(&(*ARRraf), &sarrraf, sraf)) sraf = 0;
    if (!clone_arr(&(*ARRmes), &sarrmes, smes)) smes = 0;
    if (sraf) sort_arr(&sarrraf, sraf);
    if (smes) sort_arr(&sarrmes, smes);
    while (smes > 0 && sraf > 0) {
        if (sarrmes[smes - 1] > sarrraf[sraf - 1]) {
            smes--;
            sarrmes = realloc(sarrmes, smes * sizeof(int64_t));
        } else {
            members++;
            smes--;
            sraf--;
            sarrmes = realloc(sarrmes, smes * sizeof(int64_t));
            sarrraf = realloc(sarrraf, sraf * sizeof(int64_t));
        }
    }

    free(sarrmes);
    free(sarrraf);
    return members;
}

int8_t get_mesklinites(int64_t** ARR, size_t* N) {
    int8_t result = 0;
    *N = input_n();
    if (init_arr(&(*ARR), *N)) {
        input_arr(&(*ARR), *N);
        result = 1;
    }
    return result;
}

int8_t get_rafts(int64_t** ARR, size_t* N) {
    int8_t result = 0;
    *N = input_n() * input_n();
    if (init_arr(&(*ARR), *N)) {
        input_arr(&(*ARR), *N);
        result = 1;
    }
    return result;
}

int8_t clone_arr(int64_t** ARRIN, int64_t** ARROUT, size_t N) {
    int8_t result = 1;
    if (init_arr(&(*ARROUT), N)) {
        for (size_t i = 0; i < N; i++)
            (*ARROUT)[i] = (*ARRIN)[i];
    } else {
        result = 0;
    }
    return result;
}

void input_arr(int64_t** ARR, size_t N) {
    for (size_t i = 0; i < N; i++)
        (*ARR)[i] = input_n();
}

int8_t init_arr(int64_t** ARR, size_t N) {
    int8_t result = 0;
    *ARR = malloc(N * sizeof(int64_t));
    if (*ARR != NULL) result = 1;
    return result;
}

size_t input_n() {
    size_t number = 0;
    int64_t input;
    if (scanf("%zu", &input) == 1 && input > 0)
        number = input;
    return number;
}


# C++
#include <iostream>

void sort(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] > arr[j]) {
                int t = arr[i];
                arr[i] = arr[j];
                arr[j] = t;
            }
        }
    }
}

int main() {
    int n, m, k;
    
    std::cin >> n >> m;
    int ship[n * m];
    for (int i = 0; i < n * m; i++) {
        std::cin >> ship[i];
    }
    sort(ship, n * m);
    
    std::cin >> k;
    int mesclinits[k];
    for (int i = 0; i < k; i++) {
        std::cin >> mesclinits[i];
    }
    sort(mesclinits, k);
    
    int cnt = 0;
    for (int plot = 0, mesclinit = 0; plot < n * m && mesclinit < k; plot++) {
        if (ship[plot] >= mesclinits[mesclinit]) {
            cnt++;
            mesclinit++;
        }
    }
    std::cout << cnt << "\n";
    return 0;
}



