Объединение последовательностей

Даны две бесконечных возрастающих последовательности чисел A и B. i-ый член последовательности A равен i2. i-ый член последовательности B равен i3.

Требуется найти {Cx}, где C – возрастающая последовательность, полученная при объединении последовательностей A и B. Если существует некоторое число, которое встречается и в последовательности A и в последовательности B, то в последовательность C это число попадает в единственном экземпляре.

Входные данные
В единственной строке на входе дано натуральное число x (1 ≤ x ≤ 107).

Выходные данные
Выведите {Cx}. Числа выводить в строчку, разделять пробелом.

Sample Input:
2

Sample Output:
1 4 8

Напишите программу. Тестируется через stdin → stdout
Верно решили 99 учащихся
Из всех попыток 41% верных


# ruby
x = gets.to_i
#x = 1000000
a, b, c = [], [], []
i = 1

while i <= x   do
    a.push(i*i)
    b.push(i*i*i)
    c = a + b
    
    c_uniq = []
    c.each do |j|
        if c_uniq.include?(j)
            next
        else    
            c_uniq.push(j)
        end
    end  
    
    c = c_uniq
    c.sort!
    i += 1
end   
print c.join(" ")


# python
n=int(input())
b=set([x**2 for x in range(1,n+1)])
c=set([x**3 for x in range(1,n+1)])
print(*sorted(b.union(c)))


# C#
using System;
using System.Collections.Generic;
using System.Linq;

public class HeapSort
{

    public static void Main()
    {
        
        //var a = Console.ReadLine().Split().Select(n => int.Parse(n)).ToArray();
        var i = int.Parse(Console.ReadLine());
        
        var a = new HashSet<int>();
        for (var j = 1; j < i+1; j++)
        {
            a.Add(j * j);
            a.Add(j * j * j);
        }
        var mass = a.ToArray();

        mass = Sort(mass);

        foreach(var j in mass)
            Console.Write(j + " ");

    }

    private static int[] Sort(int[] mass)
    {
        var sr = mass.Length / 2;

        if (mass.Length <= 1)
            return mass;

        return MSort(Sort(mass.Take(sr).ToArray()), Sort(mass.Skip(sr).ToArray()));
    }

    private static int[] MSort(int[] m1, int[] m2)
    {
        var m = new int[m1.Length + m2.Length];
        var a = 0;
        var b = 0;
        for(var i = 0; i < m.Length; i++)
        {
            if (a < m1.Length && b < m2.Length)
            {
                if (m1[a] < m2[b])
                    m[i] = m1[a++];
                else
                    m[i] = m2[b++];
            }
            else if (a < m1.Length)
                m[i] = m1[a++];
            else if (b < m2.Length)
                m[i] = m2[b++];
        }
        return m;
    }
}


# java
import java.util.Scanner;
import java.util.TreeSet;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int number = Integer.parseInt(input.nextLine());

        TreeSet<Long> union = new TreeSet<>();

        for (int a = 1; a <= number; a++) {
            union.add((long)Math.pow(a, 2));
            union.add((long)Math.pow(a, 3));
        }

        for(long num : union) System.out.print(num + " ");
    }
}


# C++
#include <iostream>
#include<set>
using namespace std;

 int main()
 {
     int n,i=0;
     set<int> nums;
     cin>>n;
     for(i=1;i<=n;i++){
        nums.insert(i*i);
        nums.insert(i*i*i);
     }

    for (auto num:nums){
        cout<<num<<" ";
    }

     return 0;
 }

