Палиндром_0

Палиндром - это строка, которая читается одинаково как справа налево, так и слева направо. 

На вход программы поступает набор больших латинских букв (не обязательно различных). Разрешается переставлять буквы, а также удалять некоторые буквы. Требуется из данных букв по указанным правилам составить палиндром наибольшей длины, а если таких палиндромов несколько, то выбрать первый из них в алфавитном порядке.

Входные данные
В первой строке входных данных содержится число N (1 <= N <= 100000). Во второй строке задается последовательность из N больших латинских букв (буквы записаны без пробелов).

Выходные данные
В единственной строке выходных данных выдайте искомый палиндром.

Sample Input:
3
AAB

Sample Output:
ABA

Напишите программу. Тестируется через stdin → stdout
Верно решили 90 учащихся
Из всех попыток 45% верных


# ruby
n = gets.to_i
s1 = gets.chomp.split('').map{|j| j.to_s}
s_uniq, s_odd, s_even = [], [], []

s1.each do |i|
    if s_uniq.include?(i)
        next
    else    
        s_uniq.push(i)
    end
end

s_uniq.sort!

s_uniq.each do |i|
    if s1.count(i) % 2 != 0
        s_odd.push(i)
        if s1.count(i) > 1 
            s1.count(i)-1.times do
                s_even.push(i)
            end    
        end    
    else
        (s1.count(i)/2).times do
            s_even.push(i)
        end
    end
end   

part = center = ''
part = s_even.join()
if s_odd.size > 0 then center = s_odd[0] end
puts part + center + part.reverse        


# python
from collections import Counter

cntr = Counter(open(0).read().split()[1])
part = center = ''
add_odd = True
for key, val in sorted(cntr.items()):
    if val % 2:
        if add_odd:
            center, add_odd = key, False
        val -= 1
    part += key * (val // 2)
print(part + center + part[::-1])


# JS
var stdin = process.openStdin();

stdin.addListener("data", function (d) {
  let str = d.toString().split("\n");
  str = str[1];
  let arr = [];
  let result = [];

  for (let i = 0; i < str.length; i++) 
    if (!arr[str.codePointAt(i) - 65]) arr[str.codePointAt(i) - 65] = 1;
    else arr[str.codePointAt(i) - 65]++;

  for (let i = 0; i < arr.length; i++)
    if (arr[i]) {
      let n = Math.trunc(arr[i] / 2);
      let j = 0;
      while (j++ < n) result.push(i + 65);
      arr[i] = arr[i] - n * 2;
    }

  let index = arr.indexOf(1);
  if (index !== -1)
      console.log(String.fromCharCode(...result, index + 65, ...result.reverse()))
  else
      console.log(String.fromCharCode(...result,  ...result.reverse()));
});


# C#
using System;
using System.Text;

StringBuilder palindrome;
var middle = (IsEmpty: true, Value: default(char));

{
    const char MinChar = 'A', MaxChar = 'Z';
    
    Console.ReadLine();
    var text = Console.ReadLine();
    
    var counting = new int[MaxChar - MinChar + 1];
    palindrome = new StringBuilder(capacity: text.Length);
    
    foreach (var letter in text)
        counting[letter - MinChar]++;
    
    for (int i = 0; i < counting.Length; i++)
    {
        int count = counting[i];
        if (count == 0) continue;
        
        var letter = (char)(i + MinChar);
        palindrome.Append(letter, Math.DivRem(count, 2, out int remainder));
        if (middle.IsEmpty && remainder == 1) middle = (false, letter);
    }
}

int length = palindrome.Length;
if (!middle.IsEmpty) palindrome.Append(middle.Value);

for (int i = length - 1; i >= 0; i--)
    palindrome.Append(palindrome[i]);

Console.WriteLine(palindrome);


# java
import java.util.Comparator;
import java.util.Map;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        input.nextLine();

        Map<Character, Integer> letters = input.nextLine()
                .chars()
                .boxed()
                .collect(Collectors.toMap(k -> (char)k.intValue(), v -> 1, Integer::sum));

        Map<Character, Integer> even = letters.entrySet()
                .stream()
                .filter(el -> el.getValue() % 2 == 0)
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,
                        (a, b) -> a, TreeMap::new));

        Map<Character, Integer> odd = letters.entrySet()
                .stream()
                .filter(el -> el.getValue() % 2 != 0)
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,
                        (a, b) -> a, TreeMap::new));

        for(Map.Entry<Character, Integer> entry : even.entrySet()) {
            for (int index = 0; index < entry.getValue() / 2; index++) {
                System.out.print(entry.getKey());
            }
        }

        odd.entrySet()
                .stream()
                .limit(1)
                .forEach(el -> {
                    for (int index = 0; index < el.getValue(); index++) {
                        System.out.print(el.getKey());
                    }
                });

        even.entrySet()
                .stream()
                .sorted(Map.Entry.comparingByKey(Comparator.reverseOrder()))
                .forEach(el -> {
                    for (int index = 0; index < el.getValue() / 2; index++) {
                        System.out.print(el.getKey());
                    }
                });
    }
}


# C++
#include <algorithm> 
#include <fstream> 
#include <iostream> 
#include <string> 
#include <vector> 
#include <map> 
using namespace std; 
using box_t = map<char, size_t>; 
struct Compare { 
    using value_type = pair<char, size_t>; 
    bool operator()(value_type& a, value_type& b) { 
        return a.second > b.second; 
    } 
}; 
string create_palindrome(const box_t& box) { 
    using vec_t = vector<pair<char, size_t>>; 
    vec_t even; 
    vec_t odd; 
    for (const auto& [key, value] : box) { 
        if (value & 1) odd.push_back({ key, value }); 
        else even.push_back({ key, value }); 
    } 
    Compare comp; 
    sort(odd.begin(), odd.end(), comp); 
    if (odd.size() > 1) { 
        for (auto it = odd.begin() + 1; it != odd.end(); ++it) { 
            const auto& [key, value] = *it; 
            if (value == 1) break; 
            else even.push_back({ key, value - 1 }); 
        } 
    } 
    sort(even.begin(), even.end()); 
    string line; 
    if (!even.empty()) { 
        for (const auto& [key, value] : even) { 
            line += string(value >> 1, key); 
        } 
    } 
    if (!odd.empty()) { 
        const auto& [key, value] = odd.at(0); 
        line += string(value, key); 
    } 
    if (!even.empty()) { 
        for (auto it = even.rbegin(); it != even.rend(); ++it) { 
            const auto& [key, value] = *it; 
            line += string(value >> 1, key); 
        } 
    } 
    return line; 
} 
int main() { 
    size_t n; 
    cin >> n; 
    string line; 
    line.reserve(n); 
    cin >> line; 
    box_t box; 
    for (auto ch : line) ++box[ch]; 
    const auto palindrome = create_palindrome(box); 
    cout << palindrome << '\n'; 
    //system("pause > nul"); 
    
    return 0;
}


