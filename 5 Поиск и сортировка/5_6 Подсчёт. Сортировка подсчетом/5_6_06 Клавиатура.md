Клавиатура

Всем известно, что со временем клавиатура изнашивается, и клавиши на ней начинают залипать. Конечно, некоторое время такую клавиатуру еще можно использовать, но для нажатий клавиш приходиться использовать большую силу.

При изготовлении клавиатуры изначально для каждой клавиши задается количество нажатий, которое она должна выдерживать. Если знать эти величины для используемой клавиатуры, то для определенной последовательности нажатых клавиш можно определить, какие клавиши в процессе их использования сломаются, а какие – нет.

Требуется написать программу, определяющую, какие клавиши сломаются в процессе заданного варианта эксплуатации клавиатуры.

Входные данные
Первая строка входного файла содержит целое число n (1 ≤ n ≤ 100) – количество клавиш на клавиатуре. Вторая строка содержит n целых чисел – с1, с2, … , сn, где сi (1 ≤ сi ≤ 100000) – количество нажатий, выдерживаемых i-ой клавишей. Третья строка содержит целое число k (1 ≤ k ≤ 100000) – общее количество нажатий клавиш, и последняя строка содержит k целых чисел pj (1 ≤ pj ≤ n) – последовательность нажатых клавиш.

Выходные данные
В выходной файл необходимо вывести n строк, содержащих информацию об исправности клавиш. Если i-ая клавиша сломалась, то i-ая строка должна содержать слово “yes” (без кавычек), если же клавиша работоспособна – слово “no”.

Sample Input:
5
1 50 3 4 3
16
1 2 3 4 5 1 3 3 4 5 5 5 5 5 4 5

Sample Output:
yes
no
no
no
yes

Напишите программу. Тестируется через stdin → stdout
Верно решили 98 учащихся
Из всех попыток 88% верных


# ruby
n = gets.to_i
a = gets.chomp.split().map{|j| j.to_i} # buttons
m = gets.to_i    # n press
b = gets.chomp.split().map{|j| j.to_i} # presses

0.upto(a.size-1) do |i|
    if b.count(i+1) > a[i]
        print "yes\n"
    else    
        print "no\n" 
    end    
end    


# python
n = int(input())
c = [int(i) for i in input().split()]
k = int(input())
comb = [int(i) for i in input().split()]
nk = [comb.count(i) for i in range(1, n+1)]
[print('yes' if c[i] < nk[i] else 'no') for i in range(n)]


# JS
var stdin = process.openStdin();

stdin.addListener("data", function (d) {
  let str = d.toString().split("\n");
  let limit = str[1].split(" ");
  let real = [];
  str = str[3].split(" ");

  for (let i = 0; i < str.length; i++)
    if (!real[str[i] - 1]) real[str[i] - 1] = 1;
    else real[str[i] - 1]++;
  for (let i = 0; i < limit.length; i++)
    if (limit[i] < real[i]) console.log("yes");
    else console.log("no");
});


# C#
using System;
using System.Text;

namespace STEPIK_C_SHARP
{
    class Program
    {
        static int[] GetNumberArr(string[] arr)
        {
            var numbers = new int[arr.Length];
            for (int i = 0; i < arr.Length; i++)
                numbers[i] = int.Parse(arr[i]);

            return numbers;
        }

        static void Main(string[] args)
        {
            int n = int.Parse(Console.ReadLine());
            string[] vs = Console.ReadLine().Split();
            int k = int.Parse(Console.ReadLine());
            string[] vs1 = Console.ReadLine().Split();

            int[] buttons = GetNumberArr(vs);
            int[] countButtons = GetNumberArr(vs1);
            int[] temp = new int[n];

            for (int i = 0; i < countButtons.Length; i++)
                temp[--countButtons[i]]++;

            for (int i = 0; i < buttons.Length; i++)
                if (temp[i] > buttons[i])
                    Console.WriteLine("yes");
                else
                    Console.WriteLine("no");

        }
    }
} 


# java
import java.util.Arrays;
import java.util.Map;
import java.util.Scanner;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        int keys = Integer.parseInt(input.nextLine());
        int[] keystrokes = Arrays.stream(input.nextLine().split("\\s+"))
                .mapToInt(Integer::parseInt)
                .toArray();

        int total = Integer.parseInt(input.nextLine());
        Map<Integer, Integer> map = IntStream.generate(input::nextInt)
                .limit(total)
                .boxed()
                .collect(Collectors.toMap(k -> k, v -> 1, Integer::sum));

        IntStream.range(0, keys)
                .mapToObj(x -> keystrokes[x] < map.get(x + 1) ? "yes" : "no")
                .forEach(System.out::println);
    }
}

