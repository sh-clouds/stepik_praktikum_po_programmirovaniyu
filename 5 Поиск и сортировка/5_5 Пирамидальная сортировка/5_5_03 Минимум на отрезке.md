Минимум на отрезке

Рассмотрим последовательность целых чисел длины N. По ней с шагом 1 двигается “окно” длины K, то есть сначала в “окне” видно первые K чисел, на следующем шаге в “окне” уже будут находиться K чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения “окна” определить минимум в нём.

Входные данные
В первой строке входных данных содержатся два числа N и K (1 ≤  N ≤  150000, 1 ≤ K ≤ 10000, K ≤  N) – длины последовательности и “окна”, соответственно. На следующей строке находятся N чисел – сама последовательность.

Выходные данные
Выходные данные должны содержать N − K + 1 строк – минимумы для каждого положения “окна”.

Sample Input:
7 3
1 3 2 4 5 3 1

Sample Output:
1
2
2
3
1

Напишите программу. Тестируется через stdin → stdout
Верно решили 106 учащихся
Из всех попыток 86% верных


# put your ruby code here
def tbot(m, i, n)  
    if (l = 2 * (im = i) + 1) < n and m[l] > m[im] 
        im = l
    end   

    if (r = 2 * i + 2) < n and m[r] > m[im]
        im = r
    end
    
    if i != im
        m[i], m[im] = m[im], m[i]
        tbot(m, im, n)
    end
end    
  
def tbot_sort (m)
    n = m.size
    
    (n-2).downto(0) do |i|
        tbot(m, i, n)   
    end

    (n-1).downto(1) do |i|
        m[0], m[i] = m[i], m[0]
        tbot(m, 0, i)
    end 
end
    
n, k = gets.chomp.split().map{|j| j.to_i}
a = gets.chomp.split().map{|j| j.to_i}
m = []

0.upto(n-1) do |i|
    if i+k-1 > n-1
        break
    end      
    m = a[i..i+k-1]    
    tbot_sort (m)
    print m[0]
    print "\n"
end



# python
n, k, *nums = map(int, open(0).read().split())
[print(min(nums[i: i + k])) for i in range(n - k + 1)]



# java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int length = input.nextInt(), window = Integer.parseInt(input.nextLine().trim());
        int[] array = Arrays.stream(input.nextLine().split("\\s+")).mapToInt(Integer::parseInt).toArray();

        int[] subArray = new int[window];

        for (int a = window - 1; a < length; a++) {
            System.arraycopy(array, a - window + 1, subArray, 0, subArray.length);
            System.out.println(Arrays.stream(subArray).min().getAsInt());
        }
    }
}


# C#
using System;

namespace STEPIK_C_SHARP
{
    class Program
    {
        static void Main(string[] args)
        {
            string[] vs = Console.ReadLine().Split();
            string[] temp = Console.ReadLine().Split();

            int size = int.Parse(vs[0]);
            int window = int.Parse(vs[1]);

            int[] numbers = new int[size];
            for (int i = 0; i < temp.Length; i++)
                numbers[i] = int.Parse(temp[i]);

            int start = 0, end = window, counter = 0;
            while (counter < size - window + 1)
            {
                int min = int.MaxValue;
                for (int i = start; i < end; i++)
                {
                    if (numbers[i] < min)
                        min = numbers[i];
                }

                Console.WriteLine(min);
                start++;
                end++;
                counter++;
            }
        }
    }
}


# C++
#include <iostream>
#include <algorithm>
#include <list>

int main() {
    int n, k;
    std::list<int> list;
    std::cin >> n >> k;
    
    for (int i = 0; i < k; i++) {
        int v;
        std::cin >> v;
        list.push_back(v);
    }
    
    while (n-- >= k) {
        std::cout << *std::min_element(list.begin(), list.end()) << "\n";
        
        list.pop_front();
        int v;
        std::cin >> v;
        list.push_back(v);
    }
    return 0;
}


