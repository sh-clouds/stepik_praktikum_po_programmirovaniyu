Максимальная длина монотонного фрагмента

Дана последовательность натуральных чисел, завершающаяся числом 0. Определите наибольшую длину монотонного фрагмента последовательности (то есть такого фрагмента, где все элементы, кроме первого, либо больше предыдущего, либо меньше).

Гарантируется, что в последовательности не менее двух чисел, отличных друг от друга.

Числа, следующие за числом 0, считывать не нужно.

Входные данные
Дана последовательность натуральных чисел, завершающаяся числом 0 (ноль не входит в последовательность).

Выходные данные
Выведите ответ на задачу.

Sample Input 1:
1
7
7
9
1
0

Sample Output 1:
2

Sample Input 2:
1
2
3
4
5
6
7
0

Sample Output 2:
7

Напишите программу. Тестируется через stdin → stdout
Верно решили 406 учащихся
Из всех попыток 32% верных


# ruby
a = (nums = $stdin.read.split("\n").map(&:to_i))[...(nums.find_index(0))]
cnt = 0
cnt_max = 2
UP = 1
DOWN = 0
dir = UP

a.each_cons(2) do |v|
    if (v[0] == v[1])
        cnt = 0 
        #puts cnt_max
    end    
        
    if (v[0] > v[1])
        if cnt == 0
            cnt = 2
            dir = DOWN
        else
            if dir == DOWN
                cnt += 1
                if cnt_max < cnt
                    cnt_max = cnt
                end    
            else
                dir = DOWN
                cnt = 2
            end
        end
        #puts cnt_max
    end        
                
    if (v[0] < v[1])
        if cnt == 0
            cnt = 2
            dir = UP
        else
            if dir == UP
                cnt += 1
                if cnt_max < cnt
                    cnt_max = cnt                
                end    
            else
                dir = UP
                cnt = 2
            end
        end
        #puts cnt_max
    end
end
puts cnt_max

# python
prev = max_all = max_up = max_down = 0
for x in map(int, iter(input, '0')):
    max_up += x > prev
    max_down += x < prev
    max_all = max(max_all, max_up, max_down)
    max_up, max_down = (1, max_up)[x > prev], (1, max_down)[x < prev]
    prev = x    
print(max_all)


# JS
var stdin = process.openStdin();

stdin.addListener("data", function(d) {
    let data = d.toString().split('\n');
    
    let i = 1;
    let [count_1, count_2, max_count] = [1, 1, 0];

    while ( +data[i] !== 0) {
      if ( +data[i-1] < +data[i] ) {
        count_1++;
      } else {
        if (count_1 > max_count) max_count = count_1;
        count_1 = 1;        
      }
      
      if ( +data[i-1] > +data[i] ) {
        count_2++;
      } else {
        if (count_2 > max_count) max_count = count_2;
        count_2 = 1;        
      }
       
        i++;
    }
    
    if (count_2 > max_count) max_count = count_2;
    if (count_1 > max_count) max_count = count_1;

    console.log(max_count);
  });

  
# C#
using System;

public class MainClass
{
    public static void Main()
    {
        int numCountBig = 0;
        int numCountLess = 0;

        int maxNumCount = 0;
        int max = 0;

        int num = int.Parse(Console.ReadLine());
        int previous = num;

        while (num != 0)
        {
            if (previous < num) 
            {
                numCountBig++;
                maxNumCount = numCountBig;
            }
            else if (previous > num) { numCountBig = 1; }

            if (previous > num)
            {
                numCountLess++;
                maxNumCount = numCountLess;
            }
            else if (previous < num) { numCountLess = 1; }

            if (previous == num)
            {
                numCountBig = 1;
                numCountLess = 1;
            }

            previous = num;

            num = int.Parse(Console.ReadLine());

            if (maxNumCount > max)
            {
                max = maxNumCount;
            }
        }
        Console.WriteLine(max);
    }
}


# java
import java.util.Scanner;

public class Main {
    static int counter = 1, fragment = 0;

    private static void checkUp() {
        if(counter > fragment) {
            fragment = counter;
        }
        counter = 1;
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int previous = input.nextInt(), data = input.nextInt(), increase = Integer.compare(data, previous);

        while(true) {
            if(data == 0) {
                checkUp();
                break;
            }

            if(increase == 1 && data > previous) {
                ++counter;
            }
            else if(increase == 1 && data < previous) {
                checkUp();
                increase = -1;
                ++counter;
            }
            else if(increase == 1 && data == previous) {
                checkUp();
                increase = 0;
            }
            else if(increase == -1 && data < previous) {
                ++counter;
            }
            else if(increase == -1 && data > previous) {
                checkUp();
                increase = 1;
                ++counter;
            }
            else if(increase == -1 && data == previous) {
                checkUp();
                increase = 0;
            }
            else if(increase == 0 && data > previous) {
                increase = 1;
                ++counter;
            }
            else if(increase == 0 && data < previous) {
                increase = -1;
                ++counter;
            }

            previous = data;
            data = input.nextInt();
        }

        System.out.println(fragment);
    }
}


# C
#include <stdio.h>

int main() {
    int pre = 0, cur = 0, i = 1, iup = 1, ido = 1;
    while((scanf("%d", &cur) == 1) && cur) {
        if (!pre) {
            pre = cur;
            continue;
        }

        if (pre < cur) {
            iup++;
            ido = 1;
        }
        if (pre > cur) {
            ido++;
            iup = 1;
        }
        if (pre == cur) {
            iup = 1;
            ido = 1;
        }
        
        if (i < iup) i = iup;
        if (i < ido) i = ido;
        pre = cur;
    }

    printf("%d", i);
    return 0;
}


# C++
#include <iostream>

int main() {
    int n, old = 0, i_u = 0, i_d, max_i_u = 0, max_i_d = 0;
    std::cin >> n;
    old = n;
    while (n != 0) {
        if (n > old) i_u++;
        else i_u = 1;
        if (n < old) i_d++;
        else i_d = 1;
        if (i_u > max_i_u) max_i_u = i_u;
        if (i_d > max_i_d) max_i_d = i_d;
        
        old = n;
        std::cin >> n;
    }
    std::cout << std::max(max_i_u, max_i_d) << "\n";
    return 0;
}




