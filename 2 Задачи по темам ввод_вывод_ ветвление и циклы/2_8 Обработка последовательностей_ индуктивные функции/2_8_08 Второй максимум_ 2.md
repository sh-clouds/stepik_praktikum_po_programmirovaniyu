Второй максимум - 2

Последовательность состоит из натуральных чисел и завершается числом 0. Определите значение второго по величине элемента в этой последовательности, то есть элемента, который будет наибольшим, если из последовательности удалить наибольший элемент.

Числа, следующие за числом 0, считывать не нужно.

Входные данные
Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не входит).

Выходные данные
Выведите ответ на задачу.

Sample Input:
1
7
9
0

Sample Output:
7

Напишите программу. Тестируется через stdin → stdout
Верно решили 605 учащихся
Из всех попыток 36% верных


# ruby
puts ((a = (nums = $stdin.read.split("\n").map(&:to_i))[...(nums.find_index(0))].sort)[...(a.find_index(a.max))].max)


# python
prev_mx, cur_mx = 0, 0

for el in map(int, iter(input, '0')):
    if not cur_mx:
        cur_mx = el
        continue
        
    if prev_mx < el < cur_mx:
        prev_mx = el
    elif el > cur_mx:
        prev_mx, cur_mx = cur_mx, el
        
print(prev_mx)


# JS
var stdin = process.openStdin();

stdin.addListener("data", function(d) {
    let data = d.toString().split('\n');
    let i = 0;
    let [a, b] = [ -1, -1 ];

     while ( +data[i] !== 0) { 
         if ( a < +data[i] ) {
             if ( a > b ) b = a;
             a = +data[i];
         }
         if ( b < +data[i] && +data[i] < a ) b = +data[i];
         i++;
    }

    console.log(b);
  });

  
# C#
using System;
using System.Collections.Generic;
using System.Linq;

public class MainClass
{
    public static void Main()
    {
        int num;
        List<int>arr=new List <int>();
while ((num=int.Parse(Console.ReadLine()))!=0)
        {
            arr.Add(num);
        }
        arr.Sort();
        List<int>distinct=DelDuplicate(arr);
        Console.WriteLine(distinct[^2]);
    }
    public static List<T>DelDuplicate<T>(List<T>list)
    {
     return new HashSet<T>(list).ToList();
    }
}


# java
import java.util.Scanner;
import java.util.TreeSet;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        TreeSet<Integer> set = new TreeSet<>();
        int data;

        while((data = input.nextInt()) != 0) {
            set.add(data);
        }

        System.out.println(set.lower(set.last()));
    }
}


# C
#include <stdio.h>
int main() {
    int x, mx1, mx2;
    scanf("%d%d",&mx1,&mx2);
    mx1<mx2 ? (x=mx1, mx1=mx2, mx2=x) : 0;
    while (scanf("%d",&x)==1 && x) {        
        x>mx1 ? ((mx1>mx2 ? mx2=mx1 : 0), mx1=x) : (x>mx2 && x<mx1 || x<mx2 && mx1==mx2 ? mx2=x : 0);  
    }
    printf("%d\n",mx2);
    return 0;
}


# C++
//Только из комментариев смог понять, что надо удалить все элементы, равные наибольшему.
#include <iostream>

int main() {
    int n, max1 = 0, max2 = 0;
    std::cin >> n;
    while (n != 0) {
        if (n > max1) {
            max2 = max1;
            max1 = n;
        }
        if (n < max1 && n > max2) {
            max2 = n;
        }
        std::cin >> n;
    }
    std::cout << max2 << "\n";
    return 0;
}



