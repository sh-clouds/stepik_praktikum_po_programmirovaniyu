Идеальный отряд

Как вы помните, месклиниты отправились в экспедицию. Однажды руководителю экспедиции потребовалось отправить на разведку специальный отряд, состоящих из лучших месклинитов. Для этого он выстроил всю команду в шеренгу.

Цвет панциря каждого месклинита обозначается заглавной латинской буквой (от "A" до "Z" ). В целях экономии времени руководитель собирается выбрать из шеренги несколько подряд стоящих. Кроме того, он считает, что разведка будет более удачной, если выбранный отряд будет симметричен по цветам панцирей. Например, отряд "RGBGR" будет симметричным, а отряд "RGRB"  – нет.

Требуется выбрать из шеренги месклинитов максимально возможный отряд, удовлетворяющий данным условиям.

Входные данные
Дана строка, длина которой не превосходит 255 символов – цвета месклинитов в шеренге.

Выходные данные
Выходные данные представляют собой строку – выбранный отряд месклинитов. Если возможных вариантов ответа несколько, то требуется вывести находящийся ближе к началу шеренги.

Sample Input:
ABAC

Sample Output:
ABA

Напишите программу. Тестируется через stdin → stdout
Верно решили 276 учащихся
Из всех попыток 41% верных


# ruby
s = gets
#s = 'JDSBAADDGJGOGG'
#s = 'ABAC'
#s = 'ABAQCBAABQ'
#s = 'AABB'
sz = s.size #size polindrom
sp = 0 #start pointer
w = ''
b = 0

sz.downto(2) do |j|
    if b == 1
        break
    end   
    
    sp.upto(s.size-j) do |i|
        #print ("j=#{j}, i=#{i}\n")
        w = s[i..i+j-1] 
        if w == w.reverse
            b = 1
            break
        end
    end
end    
puts w


# python
s = input()
res, n = '', len(s)
for i in range(n):
    for j in range(i + 1, n + 1):
        val = s[i:j]
        if val == val[::-1] and len(val) > len(res):
            res = val
print(res)


# JS
var stdin = process.openStdin();

function pol(str) {
  for (let i=0; i<Math.trunc(str.length/2); i++) 
    if ( str[i] !== str[str.length-1-i] ) return false;
  return true;
}

stdin.addListener("data", function(d) {
    let str = d.toString();
    let [word, len] = ['', 0];
    
    for (let i=0; i<=str.length-3; i++)
      for (let j=2; j<=str.length-i-1; j++) {
        let a = str.slice(i, i+j+1);
        if (pol(a)) 
          if (a.length > len) {
            word = a;
            len = a.length;
          }
      }    
    console.log(word);
  });
  

# C#
process.stdin.on('readable', () => {
    let data = process.stdin.read();
    if (data) {
        const bytes = data.toString().split('.');
        console.log(+!bytes.some(x => x.length > 3 || +x > 255 || !x.length));
    }
});


# java
import java.util.Scanner;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String str = sc.nextLine();
    boolean l = true;
    String maxS= "";
    for (int i = 0; i < str.length(); i++) {
      for (int j = str.length(); j > i+1; j--) {
        String t = str.substring(i, j);
        if (reverse(t).equals(t) && t.length() > maxS.length()) {
          maxS = t;
        }
      }
    }
    System.out.println(maxS);
  }
  static String reverse(String str) {
    return new StringBuilder(str).reverse().toString();
  }
}


# C
#include <stdio.h>
#include <string.h>

int is_palindrome(char* str, int l, int r);

int main() {
    char str[255];
    fgets(str, 255, stdin);

    int length = strlen(str);
    int ipal = 0, maxpal = 0;

    for (int left = 0; left < (length - 1); left++) {
        for (int right = (length - 1); right > left; right--) {
            if (str[left] < 'A' || str[left] > 'Z') continue;
            if (str[right] < 'A' || str[right] > 'Z') continue;

            if (is_palindrome(str, left, right)) {
                if ((right - left) + 1 > maxpal) {
                    ipal = left;
                    maxpal = (right - left) + 1;
                }                
            }
        }
    }

    for (int i = 0; i < maxpal; i++) printf("%c", str[ipal + i]);
    return 0;
}

int is_palindrome(char* str, int l, int r) {
    int result = 1;
    while (str[l] && str[r] && l < r) {
        if (str[l] != str[r]) {
            result = 0;
            break;
        }
        l++;
        r--;
    }
    return result;
}


# C++
#include <iostream>

bool is_palindrom(std::string s) {
    for (int i = 0; i < s.size() / 2; i++) {
        if (s[i] != s[s.size() - 1 - i]) return false;
    }
    return true;
}

int main() {
    std::string s, t, max = "";
    std::cin >> s;
    for (int i = 0; i < s.size(); i++) {
        t = "";
        for (int j = i; j < s.size(); j++) {
            t += s[j];
            if (is_palindrom(t) && t.size() > max.size()) max = t;
        }
    }
    std::cout << max << "\n";
    return 0;
}


