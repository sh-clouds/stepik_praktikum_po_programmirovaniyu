Структура set

Напишите программу, которая будет выполнять последовательность запросов вида ADD num, PRESENT num и COUNT (без параметра). Программу обязательно следует писать с использованием шаблонного типа set.

Выполнение каждого запроса вида ADD num должно добавлять элемент num во множество (если такой элемент уже есть, добавление ещё одной копии не изменяет множество), на экран при этом ничего не выводится.

При выполнении каждого запроса вида PRESENT num должно выдаваться сообщение «YES» или «NO» (большими буквами, в отдельной строке), соответственно тому, есть ли такой элемент во множестве; значение множества при этом не изменяется.

При выполнении каждого запроса вида COUNT должна выдаваться на экран в отдельной строке текущее количество различных элементов в множестве; значение множества при этом не изменяется.

Входные данные
В первой строке стандартного входного потока задано количество запросов N (1 < N < 100000), далее следуют N строк, каждая из которых содержит по одному запросу согласно описанного формата.

Значения чисел не превышают по модулю 100000000.

Выходные данные
Выводите на стандартный выход (экран) в отдельных строках результаты запросов PRESENT и COUNT; на запросы ADD ничего выводить не надо.

Sample Input:
7
ADD 5
ADD 7
COUNT
PRESENT 3
PRESENT 5
ADD 3
COUNT

Sample Output:
2
NO
YES
3

Напишите программу. Тестируется через stdin → stdout
Верно решили 352 учащихся
Из всех попыток 67% верных


# ruby
n = gets.to_i 
a, q = [], []

1.upto(n) do |i|
    q = gets.split().map{|j| j.to_s }
    #puts q
    if q[0] == 'ADD'
        #a.push(q[1])
        a = a | [q[1]]
    elsif q[0] == 'PRESENT'
        if a.include?(q[1])
            puts 'YES'
        else
            puts 'NO'            
        end        
    elsif q[0] == 'COUNT'
        puts a.size       
    end           
end


# python
s = set()
for _ in range(int(input())):
    c = input()
    if c.startswith('ADD'):
        s.add(int(c.split()[-1]))
    elif c.startswith('PRESENT'):
        n = int(c.split()[-1])
        print('YES' if n in s else 'NO')
    elif c == 'COUNT':
        print(len(s))

   


# JS
let arr = require('fs').readFileSync(0, 'utf8').split('\n').slice(1);

const set = new Set();
for (let item of arr) {
    let [query, value] = item.split(' ');
    switch (query) {
        case 'ADD':
            set.add(value);
            break;
        case 'PRESENT':
            console.log(set.has(value) ? 'YES' : 'NO');
            break;
        case 'COUNT':
            console.log(set.size);
            break;
    };
};


# C#
using System;
using System.Collections.Generic;

public class MainClass
{
    public static void Main()
    {
       int n=int.Parse(Console.ReadLine());
       string[] req;
       HashSet<int> num=new HashSet<int>();
       for(int i=0;i<n;i++)
       {
           req=Console.ReadLine().Split();
           switch(req[0])
           {
               case "ADD":
               num.Add(int.Parse(req[1]));
               break;
               case "PRESENT":
               string message=num.Contains(int.Parse(req[1]))?"YES":"NO";
               Console. WriteLine(message);
               break;
               case "COUNT":
               Console. WriteLine(num.Count);
               break;               
           }
       }
    }
}


# java
import java.util.Scanner;
import java.util.Set;
import java.util.HashSet;

class Main {
    public static void main(String[] args) {
             Scanner sc = new Scanner(System.in);
        Set<String> set = new HashSet();
        int count = sc.nextInt();
        String[] str = new String[1];
        int i = 0;
        while (i <= count) {
            str = sc.nextLine().split(" ");
            switch (str[0]) {
                case ("ADD"):
                    set.add(str[1]);
                    break;
                case ("PRESENT"):
                    System.out.println(set.contains(str[1]) ? "YES" : "NO");
                    break;
                case ("COUNT"):
                    System.out.println(set.size());
                    break;
            }
            i++;
        }
    }
}


# C
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>

struct theset {
    int64_t* values;
    size_t size;
};

void create_theset(struct theset* many);
void input(struct theset* many);
uint8_t get_action(char* command);
void action_add(struct theset* many, int64_t value);
void action_count(struct theset* many);
uint8_t action_present(struct theset* many, int64_t value, uint8_t echo);
    
int main() {
    struct theset many;
    create_theset(&many);
    input(&many);
    if (many.values != NULL) free(many.values);
    return 0;
}

uint8_t action_present(struct theset* many, int64_t value, uint8_t echo) {
    uint8_t presence = 0;
    for (size_t i = 0; i < (*many).size; i++)
        if ((*many).values[i] == value) presence = 1;
    if (echo) printf("%s\n", presence ? "YES" : "NO");
    return presence;
}

void action_count(struct theset* many) {
    printf("%zu\n", (*many).size);
}

void action_add(struct theset* many, int64_t value) {
    if (!action_present(&(*many), value, 0)) {
        (*many).size++;
        if ((*many).size == 1) {
            (*many).values = malloc(sizeof(int64_t));
        } else {
            (*many).values = realloc((*many).values, (*many).size * sizeof(int64_t));
        }
        (*many).values[(*many).size - 1] = value;
    }
}

uint8_t get_action(char* command) {
    uint8_t action = 0;
    if (strcmp("ADD", command) == 0) action = 1;
    if (strcmp("COUNT", command) == 0) action = 2;
    if (strcmp("PRESENT", command) == 0) action = 3;
    return action;
}

void input(struct theset* many) {
    size_t N;
    scanf("%zu", &N);
    for (size_t i = 0; i < N; i++) {
        char command[16];
        int64_t value;
        scanf("%s", command);
        switch(get_action(command)) {
            case 1:
                scanf("%"SCNd64, &value);
                action_add(&(*many), value);
                break;
            case 2:
                action_count(&(*many));
                break;
            case 3:
                scanf("%"SCNd64, &value);
                action_present(&(*many), value, 1);
                break;
        }
    }
}

void create_theset(struct theset* many) {
    (*many).values = NULL;
    (*many).size = 0;
}


# C++
#include <iostream>
#include <string>
#include <set>

int main() {
    // put your code here
    std::set <int> number;
    int n;
    
    std::cin >> n;
    
    for(int i = 0; i < n; ++i){
        std::string str;
        int temp;
        std::cin >> str;
        
        if(str == "ADD"){
            std::cin >> temp;
            number.insert(temp);
        }
        else if (str == "PRESENT") {
            std::cin >> temp;
            if(number.find(temp) == number.end())
                 std::cout << "NO" << std::endl;
            else
                 std::cout << "YES" << std::endl;
         }
         else {
             std::cout << number.size() << std::endl;
         }

    }
    
    return 0;
}




