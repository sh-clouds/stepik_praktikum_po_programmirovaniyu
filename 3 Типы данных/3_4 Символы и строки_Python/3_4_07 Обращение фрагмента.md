Обращение фрагмента

Дана строка, в которой буква h встречается как минимум два раза. Разверните последовательность символов, заключенную между первым и последним появлением буквы h, в противоположном порядке.

Имейте ввиду, в тексте могут встречаться заглавные буквы H.

Входные данные
Вводится строка.

Выходные данные
Выведите ответ на задачу.

Sample Input:
In the hole in the ground there lived a hobbit

Sample Output:
In th a devil ereht dnuorg eht ni eloh ehobbit

Напишите программу. Тестируется через stdin → stdout
Верно решили 303 учащихся
Из всех попыток 24% верных


# ruby
s = gets
#s = 'In tHe hole in the ground there lived a hobbit'
#s = 'In th a devil ereht dnuorg eht ni eloh ehobbit'
#s = 'If Hero is died, he died'
#s = 'If H ,deid si orehe died'
s_small = s.downcase
c = 'h'
s1 = s_small.index(c)
s2 = s_small.reverse.index(c)
s2 = s_small.size - 1 - s2
#puts s1, s2
puts s[0...s1+1] + s[s1+1..s2-1].reverse + s[s2..]


# python
s = input()
i_1, i_2 = s.lower().find('h'), s.lower().rfind('h')
print(s[:i_1 + 1] + s[i_1 + 1 : i_2][::-1] + s[i_2:])


# JS
const txt = require('fs').readFileSync(0, 'utf8');
let tmp = txt.toLowerCase();

let first_h = tmp.indexOf('h');
let last_h = tmp.lastIndexOf('h');

let left = txt.slice(0, first_h+1);
let center = txt.slice(first_h+1, last_h).split('').reverse().join('');
let right = txt.slice(last_h);

console.log(left + center + right);


# C#
using System;

public class MainClass
{
    public static void Main()
    {
        string str=Console.ReadLine();
        string strPart1;
        string strPart2;
        string strPart3;
       var sc=StringComparison.CurrentCultureIgnoreCase; 
  strPart1=str[..(str.IndexOf("h",sc)+1)];
       Console.Write(strPart1);
  strPart2=str[(str.IndexOf("h",sc)+1)..str.LastIndexOf("h",sc)];
      for(int i=1;i<strPart2.Length+1;i++)
        {
        Console.Write(strPart2[^i]); 
        }
           strPart3=str[(str.LastIndexOf("h",sc))..];
        Console.Write(strPart3);
    }
}


# java
import java.util.Scanner;
class Main {
    public static void main(String[] args) {
Scanner v = new Scanner(System.in);
String qq=v.nextLine();int perv=0,posl=0,chet=0;
for(int i=0;i<qq.length();i++){
if(qq.charAt(i)=='h'||qq.charAt(i)=='H'){if(chet==0){perv=i;}
                                         else{posl=i;}
                                         chet++;}}
StringBuilder ss= new StringBuilder(qq.substring(perv+1,posl));       
System.out.println(qq.substring(0,perv+1)+ss.reverse()+qq.substring(posl));     
    }
}


# C 
#include <stdio.h>
#include <wctype.h>
#include <string.h>

int main() {
    char str[1024] = "\0", sym = 'h';
    fgets(str, 1024, stdin);

    int i = 0, first = -1, last = -1;
    while(str[i]) {
        if (towlower(str[i]) == sym) {
            if (first == -1) first = i;
            last = i;
        }
        i++;
    }

    for (int i = 0; i <= first; i++) printf("%c", str[i]);

    char rev[1024] = "\0", buf[16] = "\0";
    int weight = 0, bufind = 0, revlen = 0;
    for (int i = first + 1; i < last; i++) {
        unsigned char c = str[i];

        if (!weight) {
            if (c <= 127) {
                weight = 1;
            } else if (c >= 248) {
                break; // неопределен вес символа(
            } else if (c >= 240) {
                weight = 4;
            } else if (c >= 224) {
                weight = 3;
            } else if (c >= 192) {
                weight = 2;
            }
        }

        if (bufind < weight - 1) {
            buf[bufind] = c;
            bufind++;
            continue;
        }
        buf[bufind] = c;
        
        revlen = strlen(rev);
        for (int i = revlen + bufind; i > bufind; i--)
            rev[i] = rev[i-1-bufind];
        for (int i = 0; i <= bufind; i++)
            rev[i] = buf[i];

        bufind = 0;
        weight = 0;
    }
    printf("%s", rev);
    
    for (int i = last; str[i]; i++) printf("%c", str[i]);
    return 0;
}

# C++ 
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    // put your code here
    std::string str;
    std::getline(std::cin, str);
    
    std::string copy;
    copy = str;
    transform(copy.begin(), copy.end(), copy.begin(), tolower);
    int start = copy.find('h');
    int end = copy.rfind('h');
    copy.erase();
    std::reverse((std::begin(str) + (start + 1)), (std::end(str) - (str.length() - end)));
    
    //А тут 50 оттенков C++
    //char - 1 байт, символы Unicode - 2 байта
    //а в 5 тесте символ - 3 байта
    for(int i = start; i < end; ++i){
        //Заменяющий символ � (1 байт 2/3 байтного символа) меньше нуля
        //если 2 символ строки от i - не является �, просто меняем местами
        if((int)str[i] < 0 && (int)str[i+2] > 0){
            std::swap(str[i], str[i+1]);
            ++i;
        }
        //если 2 символ строки от i - является �, разворачиваем обратно
        if((int)str[i] < 0 && (int)str[i+2] < 0){
            std::reverse((std::begin(str) + i), (std::end(str) - (str.length() - (i+3))));
            i += 2;
        }
    }
    
    std::cout << str << std::endl;
    return 0;
}


