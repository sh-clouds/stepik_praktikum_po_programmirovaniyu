Интересный перевод

На планете Роботов очень не любят десятичную систему счисления, поэтому они попросили Вас написать программу, которая заменяет все встречающиеся в тексте числа на эти же числа, но в двоичной системе счисления.

Входные данные
Единственная строка, состоящая из любых символов. Длина строки не превышает 255 символов. Гарантируется, что во всех числах нет ведущих нулей.

Выходные данные
Выведите преобразованную строку.

Sample Input:
6^&678JKjdkdl;?.,lk879Pk1kdfl4839

Sample Output:
110^&1010100110JKjdkdl;?.,lk1101101111Pk1kdfl1001011100111

Напишите программу. Тестируется через stdin → stdout
Верно решили 302 учащихся
Из всех попыток 49% верных


# ruby
def isDigit? c
    d = c.ord
    d >= 48 and d < 58
end    
    
s = gets.chomp
#s = '6^&678JKjdkdl;?.,lk879Pk1kdfl4839'

cnt = 0
s_dig = ''
s_new = ''

s.each_char do |i|
    cnt += 1
    if (isDigit?(i))
        s_dig += i
        #puts s_dig        
        if cnt == s.size
            s_new += s_dig.to_i.to_s(2)  
        end    
    else
        #puts 'not digit'
        if s_dig != ''
            s_new += s_dig.to_i.to_s(2)
        end
        s_new += i
        s_dig = ''
        #puts s_new
    end
end  

puts s_new


# python
s = input()
res, n = '', ''
for l in s:
    if l.isdigit():
        n += l
    elif n:
        res += bin(int(n))[2:] + l
        n = ''
    else:
        res += l
if n:
    res += bin(int(n))[2:]
print(res)


# JS
let s = require('fs').readFileSync(0, 'utf8');

let scan = s => {
    let [res, tmp] = ['', s[0]];
    for (let i = 1; i < s.length; i++) {
        if ( (isNaN(s[i-1]) && !isNaN(s[i])) || (!isNaN(s[i-1]) && isNaN(s[i])) ) {
            res += (isNaN(tmp)) ? tmp : (+tmp).toString(2);
            tmp = '';
        }
        tmp += s[i];
    }
    res += (isNaN(tmp)) ? tmp : (+tmp).toString(2);
    return res;
}

console.log(scan(s));


# C#
using System;

class Program
{
    static void Main()
    {
        string text = Console.ReadLine();
        
        string result = ConvertToBinary(text);    
        Console.WriteLine(result);     
    }
    
    static string ConvertToBinary(string text)
    {
        string result = ""; 
        int start = -1;     
     for (int i = 0; i < text.Length; i++)
        {
            if (Char.IsDigit(text[i]))
            {
                if (start == -1)
                {
                    start = i;                                            
                }
            }
            else
            {
                if (start != -1)
                {
                    int end = i - 1;
                    string number = text.Substring(start, end - start + 1);
                    int decimalNumber = Int32.Parse(number);
                    string binaryNumber = Convert.ToString(decimalNumber, 2);
                    result += text.Substring(0, start) + binaryNumber;
                    text = text.Substring(end + 1);
                    i = -1;
                    start = -1;
                }
            }
        }
        
        if (start != -1)
        {
            int end = text.Length - 1;
            string number = text.Substring(start, end - start + 1);
            int decimalNumber = Int32.Parse(number);
            string binaryNumber = Convert.ToString(decimalNumber, 2); 
            result += text.Substring(0, start) + binaryNumber; 
        }
        else 
        {
            result += text;
        }    
        return result; 
    }
}


# java
import java.util.Scanner;
class Main {
    public static void main(String[] args) {
        String line = new Scanner(System.in).nextLine();
        
        String order = line.replaceAll("\\d+", "0").replaceAll("\\D+","1");
        String [] num = line.replaceAll("\\D+", " ").trim().split(" ");
        String [] sym = line.replaceAll("\\d+", " ").trim().split(" ");
        
        int numInd = 0;
        int symInd = 0;
        for (int i = 0; i < order.length(); i++)
            System.out.print (order.charAt(i) == '0' ? 
                              Integer.toBinaryString(Integer.parseInt(num[numInd++])) :
                              sym[symInd++]);
    }
}


# C
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define BUFF_SIZE 256

char* toBin(unsigned n) {
  unsigned digits = 1;
  unsigned compare = 1;
  while (compare < n) {
    compare <<= 1;
    digits++;
  }
  if (n != compare) digits--, compare >>= 1;
  char* res = calloc(digits, sizeof(char));
  for (int i = 0; i < digits; i++) {
    res[i] = n & compare ? '1' : '0';
    compare >>= 1;
  }
  return res;
}

int main(void) {
  char str[BUFF_SIZE];
  if (scanf("%s", str) != 1) return EXIT_FAILURE;
  size_t len = strnlen(str, BUFF_SIZE);
  for (char* ptr = str; *ptr;) {
    char* bin = NULL;
    if (isdigit(*ptr)) {
      bin = toBin(strtoul(ptr, &ptr, 10));
      printf("%s", bin);
      free(bin);
    } else {
      printf("%c", *ptr);
      ptr++;
    }
  }
  puts("");
  return EXIT_SUCCESS;
}



# C++
#include <iostream>

long long dec_to_bin(int n) {
    long long res = 0, i;
    for (i = 1; i * 2 <= n; i *= 2);
    while (i >= 1) {
        res = res * 10 + n / i;
        n %= i;
        i /= 2;
    }
    return res;
}

int char_to_int(char c) {
    switch (c) {
        case '0': return 0;
        case '1': return 1;
        case '2': return 2;
        case '3': return 3;
        case '4': return 4;
        case '5': return 5;
        case '6': return 6;
        case '7': return 7;
        case '8': return 8;
        case '9': return 9;
        default: return -1;
    }
}

int main() {
    std::string s, res = "";    
    int n = -1;
    std::getline(std::cin, s);
    for (char el : s) {
        int t = char_to_int(el);
        if (t == -1) {
            if (n != -1) res += std::to_string(dec_to_bin(n));
            res += el;
            n = -1;
        } else {
            if (n == -1) {
                n = t;
            } else {
                n = n * 10 + t;
            }
        }
    }
    if (n != -1) res += std::to_string(dec_to_bin(n));
    std::cout << res << "\n";
    return 0;
}

