Сортировка точек

Выведите все исходные точки в порядке возрастания их расстояний от начала координат.

Входные данные
Программа получает на вход набор точек на плоскости. Сначала задано количество точек n, затем идет последовательность из n строк, каждая из которых содержит два числа: координаты точки. Величина n не превосходит 100, все исходные координаты – целые числа, не превосходящие 103.

Выходные данные
Необходимо вывести  все исходные точки в порядке возрастания их расстояний от начала координат. Программа выводит только координаты точек, их количество выводить не надо. Если две точки находятся на одинаковом расстоянии от начала координат - выводить их в том порядке, в котором они вводятся.

Sample Input:
2
1 2
2 3

Sample Output:
1 2
2 3

Напишите программу. Тестируется через stdin → stdout
Верно решили 274 учащихся
Из всех попыток 54% верных


# ruby
n = gets.to_i

lmax, l, x, y = 0, 0, 0, 0
ap = []

1.upto(n) do |i|
    a = gets.split().map{|j| j.to_i }
    a.push(i)
    a.push(a[0]*a[0] + a[1]*a[1])
    ap.push(a.reverse)    
end

#ap2=[]
#ap2.push([1,2,0,5].reverse)
#ap2.push([2,3,1,63].reverse) 
#ap2.push([2,1,2,5].reverse) 

#print ap2.sort

ap.sort!

ap.each do |j|
    x = j[3]
    y = j[2]  
    print "#{x} #{y}\n"       
end


#print z1


# python
lst = [list(map(int, input().split())) for _ in range(int(input()))]
dc = {}
for x, y in lst:
    l = (x ** 2 + y ** 2) ** 0.5
    dc[x, y] = l
[print(*i[0]) for i in sorted(dc.items(), key=lambda x: x[1])]


# JS
var stdin = process.openStdin();

function Obj(x,y,length) {
    this.x = +x;
    this.y = +y;
    this.length = length;
}

function my_sort(a,b) {
    if (a.length > b.length) return 1;
    if (a.length === b.length) return ;
    if (a.length < b.length) return -1;
}

stdin.addListener("data", function(d) {
    let str = d.toString().split('\n');
    let massive = [];
 
    for (let i=1; i<str.length; i++) {
        let [x,y] = str[i].split(' ');
        let length = (x**2 + y**2)*0.5;
        let obj = new Obj(x, y, length);
        massive.push(obj);
    }
    massive.sort(my_sort);
    for (let key of massive)
        console.log(key.x + ' ' + key.y);
  });

  
# C#
using System;
using System.Linq;
using System.Collections.Generic;
using System.Globalization;

public class MainClass
{
    public static void Main()
    {
      int check=int.Parse(Console.ReadLine());
      List <Point> points = new List <Point>();
      {
      for (int i=0;i<check;i++)
           {
                var coordinates=Console.ReadLine().Split(' ').Select(x=>int.Parse(x)).ToArray();
                points.Add(new Point {X=coordinates[0], Y=coordinates[1]});
           }
      }
        points.Sort((p1,p2)=>p1.DistanceFromOrigin.CompareTo(p2.DistanceFromOrigin));
        foreach (var point in points)
        {
            Console.WriteLine(point);
        }     
    }     
}
class Point
{
        public int X {get;set;}
        public int Y {get;set;}    
        
       public double DistanceFromOrigin
            {
                get {return Math.Sqrt(X*X+Y*Y);}
            }
       public override string ToString()
            {
                return $"{X} {Y}";
            }
        
}


# java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        int number = Integer.parseInt(input.nextLine());
        List<Point> points = new ArrayList<>();

        for (int a = 0; a < number; a++) {
            points.add(new Point(input.nextInt(), input.nextInt()));
        }

        Collections.sort(points, (a, b) -> Double.compare(a.getTheDistance(), b.getTheDistance()));

        for(Point p : points) System.out.println(p);
    }
}

class Point {
    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public double getTheDistance() {
        return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    }

    @Override
    public String toString() {
        return String.format("%d %d", x, y);
    }
}


# C
#include <stdio.h>
#include <stdlib.h>

#define AFTER 10

struct point {
    int x;
    int y;
};

int input(struct point** points, int* n);
void significant_numbers(double x, char* numbers);
void get_center_of_gravity(struct point** points, int n, double* Xaxes, double* Yaxes);
double get_diametr(struct point** points, int n);
void sort_by_distance(struct point** points, int n);
double get_distance(struct point point);
void swap_points(struct point** points, int a, int b);
void output(struct point** points, int n);

int main() {
    struct point* points;
    int n = 0;
    
    if (input(&points, &n)) {
        sort_by_distance(&points, n);
        output(&points, n);
        free(points);
    }
    return 0;
}

void output(struct point** points, int n) {
    for (int i = 0; i < n; i++)
        printf("%d %d\n", (*points)[i].x, (*points)[i].y);
}

void swap_points(struct point** points, int a, int b) {
    int x = (*points)[a].x;
    int y = (*points)[a].y;
    (*points)[a].x = (*points)[b].x;
    (*points)[a].y = (*points)[b].y;
    (*points)[b].x = x;
    (*points)[b].y = y;
}

double get_distance(struct point point) {
    double distance = sqrt(point.x * point.x + point.y * point.y);
    return distance;
}

void sort_by_distance(struct point** points, int n) {
    double distances[n];
    for (int i = 0; i < n; i++)
        distances[i] = get_distance((*points)[i]);
    // пузырек)
    for (int i = 0; i < n - 1; i++)
        for (int j = 0; j < n - 1 - i; j++)
            if (distances[j] > distances[j + 1]) {
                double d = distances[j];
                distances[j] = distances[j + 1];
                distances[j + 1] = d;
                swap_points(&(*points), j, j + 1);
            }
}

double get_diametr(struct point** points, int n) {
    double Mdiametr = 0.0, diametr = 0.0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) {
            if (i == j) continue;
            diametr = sqrt(
((*points)[i].x - (*points)[j].x) * ((*points)[i].x - (*points)[j].x) + 
((*points)[i].y - (*points)[j].y) * ((*points)[i].y - (*points)[j].y));
            if (diametr > Mdiametr) Mdiametr = diametr;
        }
    return Mdiametr;
}

void get_center_of_gravity(struct point** points, int n, double* Xaxes, double* Yaxes) {
    for (int i = 0; i < n; i++) {
        (*Xaxes) += (*points)[i].x;
        (*Yaxes) += (*points)[i].y;
    }
    (*Xaxes) /= n;
    (*Yaxes) /= n;
}

void significant_numbers(double x, char* numbers) {
    x -= (int)x;
    for (int i = 0; i < AFTER; i++) {
        x *= 10;
        int dig = x;
        x -= dig;
        numbers[i] = dig + '0';
    }
    // "убираем последние нули", для целого числа останется один 0
    for (int i = AFTER - 1; i > 0; i--) {
        if (numbers[i] != '0') break;
        numbers[i] = '\0';
    }
}

int input(struct point** points, int* n) {
    int result = 0;
    scanf("%d", n);
    (*points) = malloc((*n) * sizeof(struct point));
    if ((*points) != NULL) {
        result = 1;
        for (int i = 0; i < (*n); i++)
            scanf("%d %d", &((*points)[i].x), &((*points)[i].y));
    }
    return result;
}


# C++
//Делал через пару вектора f. Через first сортировал, а через second выводил.
#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>

using namespace std;

long long i, j, n, k;

long double d, a, b, v;

string s;

vector<pair<long double, string> > f;

int main()
{
    cin >> n;
    for ( i = 0; i < n; i++ )
    {
        cin >> a >> b;

        d = sqrt(pow(abs(a), 2) + pow(abs(b), 2));

        k = abs(b);
        if ( b == 0 )
        {
            s = '0';
        }
        else while(k)
        {
            j = k % 10;
            s = char(j+48) + s;
            k /= 10;
        }
        s = ' ' + s;

        k = a;
        if ( a == 0 )
        {
            s = '0' + s;
        }
        else while(k)
        {
            j = k % 10;
            s = char(j+48) + s;
            k /= 10;
        }
        f.push_back({d, s});
        s = "";
    }

    reverse(f.begin(), f.end());
    for ( i = 0; i < n-1; i++ )
    {
        for ( j = i+1; j < n; j++ )
        {
            if ( f[i].first >= f[j].first )
            {
                swap( f[i], f[j] );
            }
        }
    }

    for ( i = 0; i < n; i++ )
    {
        cout << f[i].second << endl;
    }
    return 0;
}



