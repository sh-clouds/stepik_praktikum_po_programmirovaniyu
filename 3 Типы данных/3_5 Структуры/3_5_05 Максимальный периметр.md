Максимальный периметр

Среди исходных точек найдите три, образующие треугольник с максимальным периметром. Выведите данный периметр.

Входные данные
Программа получает на вход набор точек на плоскости. Сначала задано количество точек n (2 < n < 101), затем идет последовательность из n строк, каждая из которых содержит два числа: координаты точки. Все исходные координаты – целые числа, не превосходящие 103.

Выходные данные
Необходимо вывести найденный периметр в виде действительного числа с точностью до 12 значащих цифр после запятой.

Sample Input:
4
0 0
0 1
1 0
1 1

Sample Output:
3.414213562373
Напишите программу. Тестируется через stdin → stdout
Верно решили 172 учащихся
Из всех попыток 20% верных


# ruby
n = gets.to_i

lmax, l, x, y = 0, 0, 0, 0
ap = []
a, b, c = 0, 0, 0,
1.upto(n) do |i|
    a = gets.split().map{|j| j.to_i }
    ap.push(a) 
end
#print ap

#a.push(a[0]*a[0] + a[1]*a[1])  
ap.each do |p1|
    ap.each do |p2|    
        ap.each do |p3|
            a = ( (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]) )**0.5
            b = ( (p1[0]-p3[0])*(p1[0]-p3[0]) + (p1[1]-p3[1])*(p1[1]-p3[1]) )**0.5
            c = ( (p2[0]-p3[0])*(p2[0]-p3[0]) + (p2[1]-p3[1])*(p2[1]-p3[1]) )**0.5

            l = a + b + c
            if lmax<l
                lmax = l
            end    
        end    
    end          
end

z1 = lmax.to_s
#z1 = '123.1234512'

z1i = z1.index('.') 
s_before = z1[0...z1i]
s_after_point = z1[z1i..z1i+12]
z1 = s_before + s_after_point

print z1


# python
from itertools import combinations
from math import hypot

def get_side(v, w):
    return hypot(v[0]-w[0], v[1]-w[1])
    
def get_perimeter(A, B, C):
    sides = get_side(A, B), get_side(A, C), get_side(B, C)
    return sum(sides)


n = int(input())

dots = [tuple(map(int, input().split())) for _ in range(n)]

triangles = combinations(dots, 3)

max_perimeter = 0
for triangle in triangles:
    tmp = get_perimeter(*triangle)
    if tmp > max_perimeter:
        max_perimeter = tmp

print(int(max_perimeter*10**12) / 10**12)


# JS
var stdin = process.openStdin();

stdin.addListener("data", function(d) {
    let str = d.toString().split('\n');
    let arr = [];
    let max_p = 0;
    
    for (let i=1; i<str.length; i++) {
        let [x,y] = str[i].split(' ');
        let obj = { x: +x,
                    y: +y};
        arr.push(obj);
    }
   
    for (let i=0; i<arr.length-2; i++)
        for (let j=i+1; j<arr.length-1; j++)
            for (let k=j+1; k<arr.length; k++) {
                let length1 = ((arr[i].x-arr[j].x)**2 + (arr[i].y-arr[j].y)**2)**0.5; 
                let length2 = ((arr[i].x-arr[k].x)**2 + (arr[i].y-arr[k].y)**2)**0.5;    
                let length3 = ((arr[k].x-arr[j].x)**2 + (arr[k].y-arr[j].y)**2)**0.5;
                let per = length1+length2+length3;
                if (max_p < per) max_p = per;
            }
    max_p = max_p.toString();
    let dot = max_p.indexOf('.');
    if (dot === -1) max_p = Number(max_p).toFixed(1)
    else if (max_p.length - 1 - dot > 12) max_p = max_p.slice(0,dot+1+12);
    
    console.log(max_p);    
  });

  
# C#
using System;
using System.Linq;
using System.Collections.Generic;
using System.Globalization;

public class MainClass
{
    public static void Main()
    {
      int check=int.Parse(Console.ReadLine());
      Point[]points=new Point [check];
        double max = 0;
      for (int i=0;i<check;i++)
           {
                var coordinates=Console.ReadLine().Split(' ').Select(x=>int.Parse(x)).ToArray();
                points[i]=new Point(coordinates[0], coordinates[1]);
           }
        for (int i=0; i<check - 2; i++)
        {
            for (int h = i+1; h<check-1; h++)
            {
                for (int j = 1+h; j<check; j++)
                {
                    double a = Math.Sqrt(Math.Pow(points[i].x - points[h].x, 2) + Math.Pow(points[i].y - points[h].y, 2)), b = Math.Sqrt(Math.Pow(points[i].x - points[j].x, 2) + Math.Pow(points[i].y - points[j].y, 2)), c = Math.Sqrt(Math.Pow(points[j].x - points[h].x, 2) + Math.Pow(points[j].y - points[h].y, 2));
                     if (a + b > c && a + c > b && b + c > a)
                    {
                        double p = a + b + c;
                        if (p > max) 
                            max = p;
                    }
                }
            }
        }
        Chislo(max);
    }
    public static void Chislo (double f)
       {
       string[] tokens = f.ToString("G", CultureInfo.InvariantCulture).Split(".");
       if(f%1==0)
           Console.Write($"{f:F1} ");
       else if(f%1!=0&&f.ToString().Length<12)
           Console.Write($"{f} ");  
       else if (tokens[1].Length>12)
         {
             int g=f.ToString().Length-tokens[1].Length;
             string s=Convert.ToString(f);
             s=s.Substring(0,(12+g));
             Console.Write($"{s } ");
         }
       }
     struct Point
    {
        public int x;
        public int y;
        
        public Point(int x, int y)
        {
            this.x=x;
            this.y=y;
        }
     }
}


# java
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        int number = Integer.parseInt(input.nextLine());
        List<Point> points = new ArrayList<>();

        for (int a = 0; a < number; a++) {
            points.add(new Point(input.nextInt(), input.nextInt()));
        }

        print(Point.getTheMaxPerimeter(points));
    }
    
    private static void print(double num) {
        if(Double.toString(num).substring(Double.toString(num).indexOf(".") + 1).length() > 12) {
            System.out.print(new BigDecimal(num).setScale(12, BigDecimal.ROUND_DOWN));
        }
        else {
            System.out.print(num);
        }
    }
}

class Point {
    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public static double getTheMaxPerimeter(List<Point> list) {
        double max = 0.0;

        for (int a = 0; a < list.size() - 2; a++) {
            for (int b = a + 1; b < list.size() - 1; b++) {
                for (int c = b + 1; c < list.size(); c++) {
                    double perimeter = calculate(list.get(a).x, list.get(a).y, list.get(b).x, list.get(b).y);
                    perimeter += calculate(list.get(a).x, list.get(a).y, list.get(c).x, list.get(c).y);
                    perimeter += calculate(list.get(b).x, list.get(b).y, list.get(c).x, list.get(c).y);
                    if(perimeter > max) max = perimeter;
                }
            }
        }

        return max;
    }

    private static double calculate(int x1, int y1, int x2, int y2) {
        double f = Math.abs(x1 - x2);
        double s = Math.abs(y1 - y2);
        return Math.sqrt(Math.pow(f , 2) + Math.pow(s , 2));
    }
}


# C
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define AFTER 12

struct point {
    int x;
    int y;
};

void significant_numbers(double x, char* numbers);
int input(struct point** points, int* n);
void get_center_of_gravity(struct point** points, int n, double* x, double* y);
double get_segment(struct point** points, int n, int id1, int id2);
double get_diametr_and_ids(struct point** points, int n, int* id1, int* id2);
void sort_by_distance(struct point** points, int n);
double get_distance(struct point point);
void swap_points(struct point** points, int id1, int id2);
void output(struct point** points, int n);
double find_third_point(struct point** points, int n, int id1, int id2);

int main() {
    struct point* points;
    int n = 0;
    
    if (input(&points, &n)) {
        int id1, id2, id3;
        double perimeter = 0.0;
        get_diametr_and_ids(&points, n, &id1, &id2);
        id3 = find_third_point(&points, n, id1, id2);
        perimeter = get_segment(&points, n, id1, id2) + get_segment(&points, n, id2, id3) +
get_segment(&points, n, id3, id1);
        char numbers[AFTER + 1];
        significant_numbers(perimeter, numbers);
        printf("%d.%s", (int)perimeter, numbers);
        free(points);
    }
    return 0;
}

double find_third_point(struct point** points, int n, int id1, int id2) {
    int id31 = 0, id32 = 0;
    double wayid31 = 0.0, wayid32 = 0.0;
    double maxid31 = 0.0, maxid32 = 0.0;
    for (int i = 0; i < n; i++) {
        if (i == id1 || i ==id2) continue;
        wayid31 = get_segment(&(*points), n, id1, i);
        if (wayid31 > maxid31) {
            maxid31 = wayid31;
            id31 = i;
        }
        wayid32 = get_segment(&(*points), n, id2, i);
        if (wayid32 > maxid32) {
            maxid32 = wayid32;
            id32 = i;
        }
    }
    return (maxid31 > maxid32 ? id31 : id32);
}

void output(struct point** points, int n) {
    for (int i = 0; i < n; i++)
        printf("%d %d\n", (*points)[i].x, (*points)[i].y);
}

void swap_points(struct point** points, int id1, int id2) {
    int x = (*points)[id1].x;
    int y = (*points)[id1].y;
    (*points)[id1].x = (*points)[id2].x;
    (*points)[id1].y = (*points)[id2].y;
    (*points)[id2].x = x;
    (*points)[id2].y = y;
}

double get_distance(struct point point) {
    double distance = sqrt(point.x * point.x + point.y * point.y);
    return distance;
}

void sort_by_distance(struct point** points, int n) {
    double distances[n];
    for (int i = 0; i < n; i++)
        distances[i] = get_distance((*points)[i]);
    // пузырек)
    for (int i = 0; i < n - 1; i++)
        for (int j = 0; j < n - 1 - i; j++)
            if (distances[j] > distances[j + 1]) {
                double d = distances[j];
                distances[j] = distances[j + 1];
                distances[j + 1] = d;
                swap_points(&(*points), j, j + 1);
            }
}

double get_diametr_and_ids(struct point** points, int n, int* id1, int* id2) {
    double Mdiametr = 0.0, diametr = 0.0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) {
            if (i == j) continue;
            diametr = get_segment(&(*points), n, i, j);
            if (diametr > Mdiametr) {
                Mdiametr = diametr;
                (*id1) = i;
                (*id2) = j;
            }
        }
    return Mdiametr;
}

double get_segment(struct point** points, int n, int id1, int id2) {
    double segment = sqrt(
((*points)[id1].x - (*points)[id2].x) * ((*points)[id1].x - (*points)[id2].x) + 
((*points)[id1].y - (*points)[id2].y) * ((*points)[id1].y - (*points)[id2].y));
    return segment;
}

void get_center_of_gravity(struct point** points, int n, double* x, double* y) {
    for (int i = 0; i < n; i++) {
        (*x) += (*points)[i].x;
        (*y) += (*points)[i].y;
    }
    (*x) /= n;
    (*y) /= n;
}

int input(struct point** points, int* n) {
    int result = 0;
    scanf("%d", n);
    (*points) = malloc((*n) * sizeof(struct point));
    if ((*points) != NULL) {
        result = 1;
        for (int i = 0; i < (*n); i++)
            scanf("%d %d", &((*points)[i].x), &((*points)[i].y));
    }
    return result;
}

void significant_numbers(double x, char* numbers) {
    x -= (int)x;
    for (int i = 0; i < AFTER; i++) {
        x *= 10;
        int dig = x;
        x -= dig;
        numbers[i] = dig + '0';
    }
    // "убираем последние нули", для целого числа останется один 0
    for (int i = AFTER - 1; i > 0; i--) {
        if (numbers[i] != '0') break;
        numbers[i] = '\0';
    }
}



# C++
# include <iostream>
# include <cmath>
# include <vector>
# include <iomanip>
# include <set>
# include <string>
# include <map>
# include <algorithm>
# include <sstream>
# include <utility>

using namespace std;

int main() {
    ostringstream str1;
    string s1;
    int n = 0, lastzero = 0;
    double d = 0, x = 0, y = 0, dmax = 0, p = 0, l1 = 0, l2 = 0, l3 = 0, pmax = 0, local_area = 0, max_area = 0;

    cin >> n;
    vector <pair <double, double >> a(n);
    vector <double> perimetrs;
    vector <double> area;
    vector <double> variants;
    for (int i = 0; i < n; i++) {
        cin >> x >> y;
        a[i] = { x , y };
    }

    if (n == 3) {
        for (int i = a.size() - 1; i >= 0; i--) {
            for (int j = a.size() - 2; j >= 0; j--) {
                for (int h = a.size() - 3; h >= 0; h--) {
                    l1 = sqrt(pow((a[i].first - a[j].first), 2) + pow((a[i].second - a[j].second), 2));
                    l2 = sqrt(pow((a[j].first - a[h].first), 2) + pow((a[j].second - a[h].second), 2));
                    l3 = sqrt(pow((a[i].first - a[h].first), 2) + pow((a[i].second - a[h].second), 2));
                    p = l1 + l2 + l3;
                    perimetrs.push_back(p);
                   


                }
            }
        }
        
        if ((p - (trunc(p)) == 0)) {
            cout << trunc(p) << ".0" << " ";
        }
        else if (((p - (trunc(p)) > 0))) {
            str1 << setprecision(14) << fixed << p;
            s1 = str1.str();
            s1 = s1.substr(0, s1.find('.') + 13);
            reverse(s1.begin(), s1.end());
            lastzero = s1.find_first_not_of('0');
            lastzero = s1.size() - lastzero;
            reverse(s1.begin(), s1.end());

            cout << s1.substr(0, lastzero);
        }

    }

    else if (n > 3) {

        for (int i = a.size() - 1; i >= 0; i--) {
            for (int j = a.size() - 2; j >= 0; j--) {
                for (int h = a.size() - 3; h >= 0; h--) {
                    l1 = sqrt(pow((a[i].first - a[j].first), 2) + pow((a[i].second - a[j].second), 2));
                    l2 = sqrt(pow((a[j].first - a[h].first), 2) + pow((a[j].second - a[h].second), 2));
                    l3 = sqrt(pow((a[i].first - a[h].first), 2) + pow((a[i].second - a[h].second), 2));
                    p = l1 + l2 + l3;
                    perimetrs.push_back(p);
                    p = 0;


                }
            }
        }
        sort(perimetrs.begin(), perimetrs.end());
        p = perimetrs[perimetrs.size() - 1];
        if ((p - (trunc(p)) == 0)) {
            cout << trunc(p) << ".0" << " ";
        }
        else if (((p - (trunc(p)) > 0))) {
            str1 << setprecision(14) << fixed << p;
            s1 = str1.str();
            s1 = s1.substr(0, s1.find('.') + 13);
            reverse(s1.begin(), s1.end());
            lastzero = s1.find_first_not_of('0');
            lastzero = s1.size() - lastzero;
            reverse(s1.begin(), s1.end());

            cout << s1.substr(0, lastzero);
        }

    }


    return 0;
}




