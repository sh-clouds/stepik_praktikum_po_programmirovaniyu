Диаметр множества

Выведите диаметр данного множества – максимальное расстояние между любыми двумя точками.

Входные данные
Программа получает на вход набор точек на плоскости. Сначала задано количество точек n, затем идет последовательность из n строк, каждая из которых содержит два числа: координаты точки. Величина n не превосходит 100000, все исходные координаты – целые числа, не превосходящие 103.

Выходные данные
Необходимо вывести диаметр данного множества (действительное число с  точностью до 10 значащих цифр после запятой).

Sample Input:
2
1 2
2 3

Sample Output:
1.4142135623

Напишите программу. Тестируется через stdin → stdout
Верно решили 214 учащихся
Из всех попыток 31% верных


# ruby
n = gets.to_i

lmax, l, x, y = 0, 0, 0, 0
ap = []

1.upto(n) do |i|
    a = gets.split().map{|j| j.to_i } 
    ap.push(a)
end

ap.each do |j|
    x1 = j[0]
    y1 = j[1]  
    
    0.upto(n-1) do |i|
        x2 = ap[i][0]
        y2 = ap[i][1]   

        l = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)
        if lmax < l
            lmax = l
        end    
    end
    #print x, y
        
end


z1 = (lmax**0.5).to_s
#z1 = '123.1234512'

z1i = z1.index('.') 
s_before = z1[0...z1i]
s_after_point = z1[z1i..z1i+10]
z1 = s_before + s_after_point

print z1


# python
lst = [list(map(int, input().split())) for _ in range(int(input()))]
dc = {}
for x1, y1 in lst:
    for x2, y2 in lst:
        f = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5
        dc[f] = x1, y1, x2, y2
res = str(max(dc))
print(str(round(float(res), 11))[:-1] if len(res[res.find('.') + 1:]) >= 10 else res)


# C#
using System;
using System.Linq;
using System.Collections.Generic;
using System.Globalization;

public class MainClass
{
    public static void Main()
    {
      int check=int.Parse(Console.ReadLine());
      Point[]points=new Point [check];
      double xx=0, yy=0;
      for (int i=0;i<check;i++)
           {
                var coordinates=Console.ReadLine().Split(' ').Select(x=>int.Parse(x)).ToArray();
                points[i]=new Point(coordinates[0], coordinates[1]);
           }
        double maxDiameter = 0;
        for (int i=0;i<check;i++)
        {
            for (int g=1;g<check;g++)
            {
            double a  = Math.Sqrt(Math.Pow((points[g].x-points[i].x),2)+Math.Pow((points[g].y-points[i].y),2));
            if (a>maxDiameter)
                maxDiameter = a;
            }
        }
        Chislo(maxDiameter);
    }
     public static void Chislo (double f)
       {
       string[] tokens = f.ToString("G", CultureInfo.InvariantCulture).Split(".");
       if(f%1==0)
           Console.Write($"{f:F1} ");
       else if(f%1!=0&&f.ToString().Length<12)
           Console.Write($"{f} ");  
       else if (tokens[1].Length>10)
         {
             int g=f.ToString().Length-tokens[1].Length;
             string s=Convert.ToString(f);
             s=s.Substring(0,(10+g));
             Console.Write($"{s } ");
         }
       }
    struct Point
    {
        public int x;
        public int y;
        
        public Point(int x, int y)
        {
            this.x=x;
            this.y=y;
        }
     }
}


# java
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        int number = Integer.parseInt(input.nextLine());
        List<Point> points = new ArrayList<>();

        for (int a = 0; a < number; a++) {
            points.add(new Point(input.nextInt(), input.nextInt()));
        }

        double diameter = Point.getTheDiameter(points);

        if(Double.toString(diameter).substring(Double.toString(diameter).indexOf(".") + 1).length() > 10) {
            System.out.print(new BigDecimal(diameter).setScale(10, BigDecimal.ROUND_DOWN));
        }
        else {
            System.out.print(diameter);
        }
    }
}

class Point {
    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    public static double getTheDiameter(List<Point> list) {
        double max = Long.MIN_VALUE;

        for (int a = 0; a < list.size(); a++) {
            for(int b = a + 1; b < list.size(); b++) {
                double f = Math.abs(list.get(a).x - list.get(b).x);
                double s = Math.abs(list.get(a).y - list.get(b).y);
                double current = Math.sqrt(Math.pow(f , 2) + Math.pow(s , 2));
                if(current > max) max = current;
            }
        }

        return max;
    }
}


# C
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define AFTER 10

struct point {
    int x;
    int y;
};

int input(struct point** points, int* n);
void significant_numbers(double x, char* numbers);
void get_center_of_gravity(struct point** points, int n, double* Xaxes, double* Yaxes);
double get_diametr(struct point** points, int n);

int main() {
    struct point* points;
    int n = 0;
    
    if (input(&points, &n)) {
        double Mdiametr = get_diametr(&points, n);
        char numbers[AFTER + 1];
        significant_numbers(Mdiametr, numbers);
        printf("%d.%s", (int)Mdiametr, numbers);
        free(points);
    }
    return 0;
}

double get_diametr(struct point** points, int n) {
    double Mdiametr = 0.0, diametr = 0.0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) {
            if (i == j) continue;
            diametr = sqrt(
((*points)[i].x - (*points)[j].x) * ((*points)[i].x - (*points)[j].x) + 
((*points)[i].y - (*points)[j].y) * ((*points)[i].y - (*points)[j].y));
            if (diametr > Mdiametr) Mdiametr = diametr;
        }
    return Mdiametr;
}

void get_center_of_gravity(struct point** points, int n, double* Xaxes, double* Yaxes) {
    for (int i = 0; i < n; i++) {
        (*Xaxes) += (*points)[i].x;
        (*Yaxes) += (*points)[i].y;
    }
    (*Xaxes) /= n;
    (*Yaxes) /= n;
}

void significant_numbers(double x, char* numbers) {
    x -= (int)x;
    for (int i = 0; i < AFTER; i++) {
        x *= 10;
        int dig = x;
        x -= dig;
        numbers[i] = dig + '0';
    }
    // "убираем последние нули", для целого числа останется один 0
    for (int i = AFTER - 1; i > 0; i--) {
        if (numbers[i] != '0') break;
        numbers[i] = '\0';
    }
}

int input(struct point** points, int* n) {
    int result = 0;
    scanf("%d", n);
    (*points) = malloc((*n) * sizeof(struct point));
    if ((*points) != NULL) {
        result = 1;
        for (int i = 0; i < (*n); i++)
            scanf("%d %d", &((*points)[i].x), &((*points)[i].y));
    }
    return result;
}


# C++
#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <iomanip>

using namespace std;

long long i, j, n, k;

long double d, a, b, v;

string s;

vector<pair<double, double> > x;

int main()
{
    cin >> n;
    for ( i = 0; i < n; i++ )
    {
        cin >> a >> b;
        x.push_back({a, b});
    }
    for ( i = 0; i < n-1; i++ )
    {
        for ( j = 1; j < n; j++ )
        {
            d = sqrt( pow( x[i].first - x[j].first, 2 ) + pow( x[i].second - x[j].second, 2 ) );
            if ( d > v )
            {
                v = d;
            }
        }
    }
    v *= pow(10, 10);
    k = v;
    i = 0;
    while (k)
    {
        j = k % 10;
        s = char(j + 48) + s;
        k /= 10;
        i++;
        if ( i == 10 )
        {
            s = '.' + s;
        }
    }
    j = s.length();
        for ( i = s.length()-1; i >= 0; i-- )
        {
            if ( s[i] == '0' )
            {
                j = i;
            }
            else break;
        }
    s = s.substr(0, j);
    if ( s[s.length()-1] == '.' ) s = s + '0';
    cout << s;
    return 0;
}
// JDSBAADDGJGOGG


