Суперсдвиг

Дана последовательность из N (1 ≤ N ≤ 100000) целых чисел и число K (|K| ≤ 100000). Сдвинуть всю последовательность (сдвиг - циклический) на |K| элементов вправо, если K – положительное и влево, если отрицательное.

В данной задаче нельзя использовать дополнительные массивы (списки). Обратите внимание, что нужно именно преобразовать имеющийся список и распечатать его целиком, а не создать новый, даже назвав его тем же самым именем (это возможно в языке Python).

Входные данные
В первой строке дано натуральное число N, во второй строке N целых чисел, а в последней целое число K. Все числа во входных данных не превышают 109.

Выходные данные
Требуется вывести полученную последовательность. Числа следует выводить через пробел.

Sample Input:
5
5 3 7 4 6
3

Sample Output:
7 4 6 5 3

Напишите программу. Тестируется через stdin → stdout
Верно решили 298 учащихся
Из всех попыток 39% верных


# ruby
n = gets.to_i
a = gets.chomp.split().map{|j| j.to_i}
k = gets.to_i

#n = 7
#a = [1, 2, 3, 4, 5, 6, 7]
#k = 9

#n = 5
#a = [5, 3, 7, 4, 6]
#k = 3

#n = 6
#a = [5, 3, 7, 4, 6, 9]
#k = -3

ind = k % a.size
#puts ind
if (ind)  
    a = a[a.size - ind..] + a[0...a.size - ind]    
end     
puts a.join(" ")


# python
n = int(input())
lst = list(map(int, input().split()))
k = int(input()) % n

def rotate_right(lst: list[int, ...], shift: int) -> None:
    """Функция для циклического сдвига вправо"""
    lst[:] = lst[-shift:] + lst[:-shift]

def rotate_left(lst: list[int, ...], shift: int) -> None:
    """Функция для циклического сдвига влево"""
    lst[:] = lst[shift:] + lst[:shift]

if k > 0:
    rotate_right(lst, k)
elif k < 0:
    rotate_left(lst, abs(k))

print(*lst)


# JS
var stdin = process.openStdin();

stdin.addListener("data", function(d) {
    let str = d.toString().split('\n');
    let n = +str[2];
    str = str[1].split(' ');
    let result = '';
    
    n = n%str.length;
    if (n<0) n = str.length+n;
    
    for (let i=1; i<=n; i++) 
        str.unshift(str.pop()); 
    
    for (let key of str) result = result + key + ' '; 
    console.log(result);
  });

  
# C#
using System;
using System.Collections.Generic;

public class MainClass
{
    public static void Main()
    {
            int n = int.Parse(Console.ReadLine());
            var ints = new List<int>(Array.ConvertAll(Console.ReadLine().Split(),int.Parse));
            int k = int.Parse(Console.ReadLine());
            int steps=k % n;
            int sdvig = steps < 0 ? n+steps : steps;
            for (int i = 1; i <= sdvig; i++)
            {
                ints.Insert(0, ints[n-1]);
                ints.RemoveAt(n);
            }
            foreach (int i in ints) 
            Console.Write(i+" ");
    }
}


# java
import java.util.ArrayList;
import java.util.Scanner;

public class Main {
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    ArrayList<Integer> list = new ArrayList<>();
    for (int i = 0; i < n; i++) {
      list.add(i, sc.nextInt());
    }
    int k = sc.nextInt();
    if (k > 0) {
      for (int i = 0; i < k; i++) {
        list.add(0, list.get(n - 1));
        list.remove(n);
      }
    }
    else {
      for (int i = 0; i < Math.abs(k); i++) {
        list.add(n, list.get(0));
        list.remove(0);
      }
    }
    for (Integer integer : list) {
      System.out.print(integer+" ");
    }
  }
}


# C
#include <inttypes.h>
#include <stdio.h>

void puton(size_t start, size_t current, size_t step, size_t n, int64_t* array);
int8_t puton_check(size_t start, size_t step, size_t n, size_t check);

int main() {
    size_t N = 0;
    scanf("%zu", &N);
    int64_t array[N];
    for (size_t i = 0; i < N; i++)
        scanf("%"SCNd64, &array[i]);
    int64_t K = 0;
    scanf("%"SCNd64, &K);
    
    while(K < 0) K += N;

    puton(0, 0, K, N, array);
    for (size_t i = 1; i < N; i++) {
        // проверка проходился ли этот элемент массива ранее
        int8_t itwas = 0;
        for (size_t j = 0; j < i; j++) {
            itwas = puton_check(j, K, N, i);
            if (itwas) break;
        }
        if (!itwas) puton(i, i, K, N, array);
    }

    for (size_t i = 0; i < N; i++)
        printf("%"PRId64" ", array[i]);

    return 0;
}

int8_t puton_check(size_t start, size_t step, size_t n, size_t check) {
    int8_t result = 0;
    size_t current = start;
    size_t next = (current + step + n) % n;
    do {
        if (check == next) {
            result = 1;
            break;
        }
        current = next;
        next = (current + step + n) % n;
    } while (next != start);
    return result;
}

void puton(size_t start, size_t current, size_t step, size_t n, int64_t* array) {
    int64_t item_current = array[current];
    size_t next = (current + step + n) % n;
    if (next != start) puton(start, next, step, n, array);
    array[next] = item_current;
}


# C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int main(){
int n,k;
cin>>n;
vector<int> vals(n);
for (int i=0;i<n;i++)
    cin>> vals[i];
cin>>k;

int offset=((k>0)?(n- abs(k)%n):(abs(k)%n));
rotate(vals.begin(),vals.begin()+offset,vals.end());

for (auto v:vals)
    cout<< v<<" ";

return 0 ;
}



