Спираль

Требуется заполнить массив размера N × N единичками по спирали (начиная с верхнего левого угла по часовой стрелке, см. пример).

Входные данные
С клавиатуры вводится число N (нечетное, натуральное и не превышающее 50).

Выходные данные
Требуется вывести на экран построенную спираль.

Sample Input:
7

Sample Output:
1111111
0000001
1111101
1000101
1011101
1000001
1111111

Напишите программу. Тестируется через stdin → stdout
Верно решили 108 учащихся
Из всех попыток 27% верных


# ruby
n = gets.to_i
a = []

0.upto(n-1) do |x|   
    a.push([])
end

0.upto(n-1) do |i|
    0.upto(n-1) do |j|
        a[i][j] = 0
    end    
end

i = 0
while (i<n)
    (i-1).upto(n-i-1) do |j|
        a[i][j] = 1   
    end
    
    (i+1).upto(n-i-1) do |j|
        a[j][n-i-1] = 1   
    end    
    
    i.upto(n-i-2) do |j|
        a[n-i-1][j] = 1   
    end   
    
    (i+2).upto(n-i-1) do |j|
        a[j][i] = 1   
    end  
    
    i+=2     
end
        
a.each do |i|  
    print i.join("")
    print "\n"      
end




# python
n = m = int(input())
matrix = [[0] * m for _ in range(n)]
k = 0
while k < n + m:
    for j in range(max(k - 1, 0), m - k): 
        matrix[k][j] = 1
    for i in range(k + 1, n - k - 1): 
        matrix[i][m - 1 - k] = 1   
    for j in range(m - 1 - k, k - 1, -1):
        matrix[n - 1 - k][j] = 1       
    for i in range(n - k - 2, k + 1, -1):
        matrix[i][k] = 1     
    k += 2
    
for row in matrix:
    print(*row, sep='')


# JS
var stdin = process.openStdin();
function draw(arr, x, y, xx, yy){
    let count = 0;
    for (let i=0; i<arr.length; i++ ) {
        if (x+xx>=0 && y+yy>=0 && x+xx<arr.length && y+yy<arr.length && arr[x+xx][y+yy] === 1 ) break;
        arr[x][y]=1;
        x = x + xx;
        y= y + yy;        
        count++;    
    }
    return [x-xx,y-yy, count];
}

stdin.addListener("data", function(d) {
    let n = +d.toString();
    let result = [];
    let [x,y, count] = [0,0,1];
    for (let i=0; i<n; i++)
        result.push(new Array(n).fill(0));
    
    while(true && n!==1) { 
    if (count !==0 ) [x,y,count] = draw(result,x,y,0,1);
        else break;
    if (count !==0 ) [x,y,count] = draw(result,x,y,1,0);
        else break;
    if (count !==0 ) [x,y,count] = draw(result,x,y,0,-1);
        else break;
    if (count !==0 ) [x,y,count] = draw(result,x,y,-1,0);
        else break;
    }    
    if (n===1) console.log(1); else
    for (let key of result) console.log(key.join(''));
  });


  
# C$
using System;

public class MainClass
{
    public static void Main()
    {
        int n = int.Parse(Console.ReadLine());   
        int[,] arr = new int[n, n];
        n--;
        int steps = 0;
        int a = 0;        

        while (steps<=n/4)
        {
            for (int y = a, x=a-1<0?0:a-1; x<n-a; x++)
            { arr[y, x] = 1;}
            for (int y = a, x=n-a; y<=n-a; y++)
            { arr[y, x] = 1;}
            for (int y = n - a, x=n-a; x>a; x--)
            { arr[y, x] = 1;}
            for (int y = n-a, x = a; y>1+a; y--)
            { arr[y, x] = 1;}
            steps++;
            a +=2;
        }
        for (int i = 0; i <= n; i++)
        {
            for (int j = 0; j <= n; j++)
            {
                Console.Write(arr[i, j]);
            }
            Console.WriteLine();
        }
    }
}


# java
import java.util.Scanner;
class Main {
    public static void main(String[] args) {
    Scanner myscan=new Scanner(System.in);
        int n=myscan.nextInt();
        int mas[][]=new int[n][n];
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                mas[i][j]=0;
        for(int t=0,i=0,j=0;t<10;t++,t++){
        while(j<n-1&&j<n-t-1){mas[i][j]=1;j++;}
        while(i<n-1&&i<n-t-1){mas[i][j]=1;i++;}
        while(j>=t+1){mas[i][j]=1;j--;}
        while(i>t+2){mas[i][j]=1;i--;}
        mas[i][j]=1;}
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++){
        System.out.print(mas[i][j]);
                System.out.print(j==n-1&&i!=n-1?"\n":"");}
    }
}



# C
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>

void input_n(size_t* N);
int8_t init_matrix(int64_t*** arr, size_t N, size_t M);
void free_matrix(int64_t*** arr, size_t N);
void echo_matrix(int64_t*** arr, size_t N, size_t M);
void fill_matrix(int64_t*** arr, size_t N);
int8_t one_more_step(int64_t*** arr, size_t N, size_t M, size_t y, size_t x, int8_t wy, int8_t wx);
int8_t future_neighbours(int64_t*** arr, size_t N, size_t M, size_t y, size_t x);

int main() {
    size_t N, M;
    input_n(&N);
    M = N;
    int64_t** matrix = NULL;
    if (N && init_matrix(&matrix, N, M)) {
        fill_matrix(&matrix, N);
        echo_matrix(&matrix, N, M);
        free_matrix(&matrix, N);
    }
    return 0;
}

int8_t future_neighbours(int64_t*** arr, size_t N, size_t M, size_t y, size_t x) {
    int64_t neighbour = 1;
    int8_t neighbours =
(x > 0 && y > 0 && (*arr)[y - 1][x - 1] == neighbour) +
(y > 0 && (*arr)[y - 1][x] == neighbour) +
(x + 1 < M && y > 0 && (*arr)[y - 1][x + 1] == neighbour) +
(x > 0 && (*arr)[y][x - 1] == neighbour) +
(x + 1 < M && (*arr)[y][x + 1] == neighbour) +
(x > 0 && y + 1 < N && (*arr)[y + 1][x - 1] == neighbour) +
(y + 1 < N && (*arr)[y + 1][x] == neighbour) +
(x + 1 < M && y + 1 < N && (*arr)[y + 1][x + 1] == neighbour);
    return neighbours;
}

int8_t one_more_step(int64_t*** arr, size_t N, size_t M, size_t y, size_t x, int8_t wy, int8_t wx) {
    int8_t step = 1;
    // 1. следущий шаг выход за пределы - стоп
    // 2. через клетку предел - шаг продолжается
    // 3. через клетку "след" - стоп
    if ((wy && (y + wy == -1 || y + wy == N)) || (wx && (x + wx == -1 || x + wx == M))) {
        step = 0;
    } else if ((wy && (y + wy == 0 || y + wy + 1 == N)) || (wx && (x + wx == 0 || x + wx + 1 == M))) {
        step = 1;
    } else if ((wy && (*arr)[y + 2 * wy][x]) || (wx && (*arr)[y][x + 2 * wx])) {
        step = 0;
    }
    return step;
}

void fill_matrix(int64_t*** arr, size_t N) {
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < N; j++)
            (*arr)[i][j] = 0;

    int64_t ai = 0, aj = 0;
    int8_t gogo = 1, goi = 0, goj = 1, turn; // направление goi/goj == -1 | 0 | +1

    while (gogo) {
        (*arr)[ai][aj] = 1;
        if (!one_more_step(&(*arr), N, N, ai, aj, goi, goj)) {
            turn = goi;
            goi = !goi ? goj : 0;
            goj = -turn;
            if (!one_more_step(&(*arr), N, N, ai, aj, goi, goj)) gogo = 0;
        }
        ai += goi;
        aj += goj;
        // 4. для следущей клетки не больше 2х "со следом" / "четная" матрица
        if (future_neighbours(&(*arr), N, N, ai, aj) > 2) gogo = 0;
    }
}

void echo_matrix(int64_t*** arr, size_t N, size_t M) {
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            printf("%"PRId64"%s", (*arr)[i][j], j + 1 == M ? "\n" : "");
}

void free_matrix(int64_t*** arr, size_t N) {
    for (size_t i = 0; i < N; i++) free((*arr)[i]);
    free(*arr);
}

int8_t init_matrix(int64_t*** arr, size_t N, size_t M) {
    int8_t result = 0;
    *arr = malloc(N * sizeof(int64_t*));
    if (*arr != NULL) {
        result = 1;
        for (size_t i = 0; i < N; i++) {
            (*arr)[i] = malloc(M * sizeof(int64_t));
            if ((*arr)[i] == NULL) {
                result = 0;
                free_matrix(&(*arr), i);
                break;
            }
        }
    }
    return result;
}

void input_n(size_t* N) {
    int64_t num;
    *N = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
}


# C++
#include<iostream>

using namespace std;

int main(int argc, char *argv[])
{
    int size;
    cin >> size;
    int matrix[size][size];
        
    for (int i = 0; i < size; i++){
        for (int j = 0; j < size; j++){
            matrix[i][j] = 0;
        }
    }
        
    for (int i = 0; i < size; i += 2){
        
        for (int j = i - 1; j < size - i; j++){
            matrix[i][j] = 1;
        }
    
        for (int j = i + 1; j < size - i; j++){
            matrix[j][size - i - 1] = 1;        
        }
        
        for (int j = i; j < size - i - 1; j++){
            matrix[size - i - 1][j]= 1;
        }
        
        for (int j = i + 2; j < size - i; j++){
            matrix[j][i]= 1;
        }
    }
        
    for (int i = 0; i < size; i++){
        for (int j = 0; j < size; j++){
            cout << matrix[i][j];
        }
        cout << endl;
    }
    
} 