Треугольник Паскаля

Даны два числа n и m. Создайте двумерный массив [n][m] и заполните его по следующим правилам: Числа, стоящие в строке 0 или в столбце 0 равны 1 (A[0][j]=1, A[i][0]=1). Для всех остальных элементов массива A[i][j]=A[i-1][j]+A[i][j-1], то есть каждый элемент равен сумме двух элементов, стоящих слева и сверху от него.

Входные данные
Программа получает на вход два числа n и m.

Выходные данные
Выведите данный массив.

Sample Input:
3 3

Sample Output:
1 1 1
1 2 3
1 3 6

Напишите программу. Тестируется через stdin → stdout
Верно решили 272 учащихся
Из всех попыток 56% верных


# ruby
n,m = gets.chomp.split(' ').map { |j| j.to_i }
num_row, num_col = 0, 0
a = []

0.upto(n-1) do |i|
    a.push([])
end

0.upto(n*m-1) do |i|
    num_row = i / m
    num_col = i - (num_row * m)
    if num_row == 0 or num_col == 0
        a[num_row].push(1)
    else
        a[num_row].push(a[num_row-1][num_col] + a[num_row][num_col-1])
    end
end

a.each do |i|
    puts i.join(" ")
end  


# python
n, m = map(int, input().split())
mas = [[1 for _ in range(m)] for _ in range(n)]
for i in range(1, n):
    for j in range(1, m):
        mas[i][j] = mas[i-1][j] + mas[i][j-1]
[print(*i) for i in mas]


# JS
let [n, m] = require('fs').readFileSync(0, 'utf8').split(' ').map(Number);

let arr = [];
for (let i = 0; i < n; i++) {
    arr[i] = [];
    for (let j = 0; j < m; j++)
        arr[i][j] = i == 0 || j == 0 ? 1 : arr[i][j] = arr[i-1][j] + arr[i][j-1];
}

for (let row of arr)
    console.log(row.join(' '));


# C#
// Multidimensional array
using System;

public class PascalsTriangle
{
    public static void Main()
    {
        int rows, columns;
        {
            int[] dimension = Array.ConvertAll(Console.ReadLine().Split(), Convert.ToInt32);
            rows = dimension[0];
            columns = dimension[1];
        }
        int[,] pascal = new int[rows, columns];
        
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < columns; j++)
            {
                if (i == 0) { pascal[i, j] = 1; continue; }
                
                if (j == 0) pascal[i, j] = 1;
                else pascal[i, j] = pascal[i, j-1] + pascal[i-1, j];
            }
        
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < columns; j++)
            {
                Console.Write(pascal[i, j]);
                Console.Write((j < columns - 1) ? " " : "\n");
            }
    }
}


# java
import java.util.Scanner;
class Main {
    public static void main(String[] args) {
Scanner v=new Scanner(System.in);
int n=v.nextInt(),m=v.nextInt();
int vas[][]=new int[n][m];
for(int i=0;i<n;i++){
    for(int j=0;j<m;j++){
    if(i==0||j==0){vas[i][j]=1;}
    else{vas[i][j]=vas[i-1][j]+vas[i][j-1];}
    if(j==m-1){System.out.print(vas[i][j]);}
    else{System.out.print(vas[i][j]+" ");}}
System.out.println("");}
    }
}


# C
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

void input_n_m(size_t* N, size_t* M);
int8_t init_matrix(int64_t*** arr, size_t N, size_t M);
void input_matrix(int64_t*** arr, size_t N, size_t M);
void free_matrix(int64_t*** arr, size_t N);
void echo_matrix(int64_t*** arr, size_t N, size_t M);
int64_t get_sum_of_string(int64_t*** arr, size_t i, size_t M);
int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M);
int64_t get_max_in_matrix(int64_t*** arr, size_t N, size_t M);
void fill_matrix(int64_t*** arr, size_t N, size_t M);

int main() {
    size_t N, M;
    input_n_m(&N, &M);
    int64_t** matrix = NULL;
    if (N && M && init_matrix(&matrix, N, M)) {
        fill_matrix(&matrix, N, M);
        echo_matrix(&matrix, N, M);
        free_matrix(&matrix, N);
    }
    return 0;
}

void fill_matrix(int64_t*** arr, size_t N, size_t M) {
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            if (i == 0 || j == 0) {
                (*arr)[i][j] = 1;
            } else {
                (*arr)[i][j] = (*arr)[i-1][j] + (*arr)[i][j-1];
            }
}

int64_t get_max_in_matrix(int64_t*** arr, size_t N, size_t M) {
    int64_t max = LLONG_MIN;
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            if ((*arr)[i][j] > max)
                max = (*arr)[i][j];
    return max;
}

int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M) {
    int64_t max = LLONG_MIN;
    for (size_t j = 0; j < M; j++)
        if ((*arr)[i][j] > max)
            max = (*arr)[i][j];
    return max;
}

int64_t get_sum_of_string(int64_t*** arr, size_t i, size_t M) {
    int64_t sum = 0;
    for (size_t j = 0; j < M; j++) sum += (*arr)[i][j];
    return sum;
}

void echo_matrix(int64_t*** arr, size_t N, size_t M) {
    for (size_t i = 0; i < N; i++) {
        for (size_t j = 0; j < M; j++) {
            printf("%"PRId64, (*arr)[i][j]);
            printf("%s", j < M - 1 ? " " : "\n");
        }
    }
}

void free_matrix(int64_t*** arr, size_t N) {
    for (size_t i = 0; i < N; i++) free((*arr)[i]);
    free(*arr);
}

void input_matrix(int64_t*** arr, size_t N, size_t M) {
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            scanf("%"SCNd64, &((*arr)[i][j]));
}

int8_t init_matrix(int64_t*** arr, size_t N, size_t M) {
    int8_t result = 0;
    *arr = malloc(N * sizeof(int64_t*));
    if (*arr != NULL) {
        result = 1;
        for (size_t i = 0; i < N; i++) {
            (*arr)[i] = malloc(M * sizeof(int64_t));
            if ((*arr)[i] == NULL) {
                result = 0;
                free_matrix(&(*arr), i);
                break;
            }
        }
    }
    return result;
}

void input_n_m(size_t* N, size_t* M) {
    int64_t num;
    *N = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
    *M = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
}

