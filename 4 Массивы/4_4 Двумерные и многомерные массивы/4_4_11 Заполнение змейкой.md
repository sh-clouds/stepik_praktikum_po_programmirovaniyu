Заполнение змейкой

Даны числа n и m. Создайте массив A[n][m] и заполните его змейкой (см. пример).

Входные данные
Программа получает на вход два числа n и m.

Выходные данные
Программа должна вывести  полученный массив, отводя на вывод каждого числа ровно 3 символа.

Sample Input:
4 10

Sample Output:
  0  1  2  3  4  5  6  7  8  9
 19 18 17 16 15 14 13 12 11 10
 20 21 22 23 24 25 26 27 28 29
 39 38 37 36 35 34 33 32 31 30

Напишите программу. Тестируется через stdin → stdout
Верно решили 187 учащихся
Из всех попыток 28% верных


# ruby
n,m = gets.chomp.split(' ').map { |j| j.to_i }
a = []

#n,m = 5, 10

0.upto(n) do |i|
    a.push([])
end

0.upto(n-1) do |i|
    0.upto(m-1) do |j|
        a[i].push(-1)
    end    
end

d = 0
nk = (n+1)/2

0.upto (nk-1) do |k|
    i = 2*k
    0.upto(m-1) do |j| #TOP
        a[i][j] = d
        d += 1        
    end 
    
    if i >= n-1 
        break
    end
    
    i = 2*k+1     
    0.upto(m-1) do |j| #BOTTOM
        a[i][m-1-j] = d 
        d += 1  
    end  
end

a.each do |i|
    i.each do |j|
        print j.to_s.rjust(3)  
    end
    print "\n"      
end  


# python
n, m = map(int, input().split())
mas = [[0 for _ in range(m)] for _ in range(n)]
x = 0
for i in range(n):
    if i % 2 == 0:
        for j in range(m):
            mas[i][j] = x
            x += 1
    else:
        for j in range(-1, -m - 1, -1):
            mas[i][j] = x
            x += 1
            
[print(''.join(map(lambda i: str(i).rjust(3), s))) for s in mas]


# JS
let [n, m] = require('fs').readFileSync(0, 'utf8').split(' ').map(Number);

const pattern = [...Array(n*m).keys()].map(z => String(z).padStart(3));

let res = [];
for (let i = 0; i < n; i++)
    res[i] = i%2 ? pattern.slice(i*m, (i+1)*m).reverse() : pattern.slice(i*m, (i+1)*m);

for (let row of res)
    console.log(row.join(''));


# C#
using System;

public class SnakeArray
{
    public static void Main()
    {
        int rows, cols;
        {
            int[] dimension = Array.ConvertAll(Console.ReadLine().Split(), Convert.ToInt32);
            rows = dimension[0];
            cols = dimension[1];
        }
        var snake = new int[rows, cols];
        var value = 0;
        
        for (int i = 0; i < rows; i++)
        {
            if (i % 2 == 0)
                for (int j = 0; j < cols; j++)
                    snake[i, j] = value++;
            else
                for (int j = cols - 1; j >= 0; j--)
                    snake[i, j] = value++;
        }
        
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
                Console.Write($"{snake[i, j], 3}");
            Console.WriteLine();
        }
    }
}


# java
import java.util.Scanner;
import java.util.stream.IntStream;

public class Main {
    public static void main(String args[]) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt(), m = Integer.parseInt(input.nextLine().trim());

        int[][] matrix = new int[n][m];

        IntStream.range(0, n).forEach(x -> IntStream.range(0, m).forEach(y -> {
            if(x % 2 == 0) matrix[x][y] = x * m + y;
            else matrix[x][y] = x * m + m - 1 - y;
        }));

        IntStream.range(0, n).forEach(x -> IntStream.range(0, m).forEach(y -> {
            if(y < m - 1) System.out.printf("%3d", matrix[x][y]);
            else System.out.printf("%3d%n", matrix[x][y]);
        }));
    }
}


# C
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

void input_n(size_t* N);
void input_n_m(size_t* N, size_t* M);
void input_matrix(int64_t*** arr, size_t N, size_t M);
int8_t init_matrix(int64_t*** arr, size_t N, size_t M);
void free_matrix(int64_t*** arr, size_t N);
void echo_matrix(int64_t*** arr, size_t N, size_t M, size_t type);
int64_t get_sum_of_string(int64_t*** arr, size_t i, size_t M);
int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M);
int64_t get_max_in_matrix(int64_t*** arr, size_t N, size_t M);
void fill_matrix(int64_t*** arr, size_t N, size_t M);

int main() {
    size_t N, M;
    input_n_m(&N, &M);
    int64_t** matrix = NULL;
    if (N && M && init_matrix(&matrix, N, M)) {
        fill_matrix(&matrix, N, M);
        echo_matrix(&matrix, N, M, 2);
        free_matrix(&matrix, N);
    }
    return 0;
}

void fill_matrix(int64_t*** arr, size_t N, size_t M) {
    size_t ci = 0, cj = 0;
    int64_t item = 0, way = 1;
    while (ci < N) {
        while (cj >= 0 && cj < M) {
           (*arr)[ci][cj] = item++;
            cj += way;
        }
        way = -way;
        cj += way;
        ci++;
    }
}

int64_t get_max_in_matrix(int64_t*** arr, size_t N, size_t M) {
    int64_t max = LLONG_MIN;
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            if ((*arr)[i][j] > max)
                max = (*arr)[i][j];
    return max;
}

int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M) {
    int64_t max = LLONG_MIN;
    for (size_t j = 0; j < M; j++)
        if ((*arr)[i][j] > max)
            max = (*arr)[i][j];
    return max;
}

int64_t get_sum_of_string(int64_t*** arr, size_t i, size_t M) {
    int64_t sum = 0;
    for (size_t j = 0; j < M; j++) sum += (*arr)[i][j];
    return sum;
}

void echo_matrix(int64_t*** arr, size_t N, size_t M, size_t type) {
    for (size_t i = 0; i < N; i++) {
        for (size_t j = 0; j < M; j++) {
            if (type == 1) {
                printf("%"PRId64, (*arr)[i][j]);
                if (j < M - 1) printf(" ");
            } else if (type == 2) {
                printf("%3"PRId64, (*arr)[i][j]);
            }
            if (j == M - 1) printf("\n");
        }
    }
}

void free_matrix(int64_t*** arr, size_t N) {
    for (size_t i = 0; i < N; i++) free((*arr)[i]);
    free(*arr);
}

int8_t init_matrix(int64_t*** arr, size_t N, size_t M) {
    int8_t result = 0;
    *arr = malloc(N * sizeof(int64_t*));
    if (*arr != NULL) {
        result = 1;
        for (size_t i = 0; i < N; i++) {
            (*arr)[i] = malloc(M * sizeof(int64_t));
            if ((*arr)[i] == NULL) {
                result = 0;
                free_matrix(&(*arr), i);
                break;
            }
        }
    }
    return result;
}

void input_matrix(int64_t*** arr, size_t N, size_t M) {
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            scanf("%"SCNd64, &((*arr)[i][j]));
}

void input_n_m(size_t* N, size_t* M) {
    int64_t num;
    *N = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
    *M = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
}

void input_n(size_t* N) {
    int64_t num;
    *N = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
}




# C++
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    int n, m, k=0;
    cin >> n >> m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (i%2)
                arr[i][m-j-1] = k++;
            else
                arr[i][j] = k++;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            cout << setw(3) << arr[i][j];
        cout << "\n";    
    }
    return 0;
}

