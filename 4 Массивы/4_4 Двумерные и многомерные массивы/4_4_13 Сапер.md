Сапер

Напишите программу, отображающую игровое поле для игры "Сапер".

Входные данные

Даны числа N и M (целые, положительные, не превышают 32) – количество строк и столбцов в поле соответственно, далее число W (целое, неотрицательное, не больше 1000) – количество мин на поле, далее следует W пар чисел, координаты мины на поле (первое число – строка, второе число – столбец).

Выходные данные

Требуется вывести на экран поле. Формат вывода указан в примере.

Sample Input:

3 2
2
1 1
2 2
Sample Output:

* 2
2 *
1 1

Напишите программу. Тестируется через stdin → stdout
Верно решили 132 учащихся
Из всех попыток 41% верных


# ruby
n,m = gets.chomp.split(' ').map { |j| j.to_i }
k = gets.to_i
a = []

0.upto(n+1) do |i|
    a.push([])
end

0.upto(n+1) do |i|
    0.upto(m+1) do |j|
        a[i][j] = 0
    end    
end

0.upto(k-1) do |ii|
    i,j = gets.chomp.split(' ').map { |j| j.to_i }
    a[i][j] = "*"  
end

1.upto(a.size-2) do |i|
    1.upto(a[i].size-2) do |j|
        k = 0
        if(a[i][j] != '*')
            if(a[i - 1][j - 1] == '*') then k += 1 end 
            if(a[i - 1][j] == '*')     then k += 1 end
            if(a[i - 1][j + 1] == '*') then k += 1 end                  
            if(a[i][j - 1] == '*')     then k += 1 end
            if(a[i][j] == '*')         then k += 1 end               
            if(a[i][j + 1] == '*')     then k += 1 end
            if(a[i + 1][j - 1] == '*') then k += 1 end
            if(a[i + 1][j] == '*')     then k += 1 end
            if(a[i + 1][j + 1] == '*') then k += 1 end
            if(k != 0) then a[i][j] = k end
       end
    end    
end
                    
1.upto(a.size-2) do |i|
    1.upto(a[i].size-2) do |j|
        if (j < a[i].size() - 2)
            print "#{a[i][j]} "          
        else
            print "#{a[i][j]}"
        end                 
   end
   print "\n"                     
end 


# python
def counter_mines(x, y):
  cm = 0
  for i in range(x-1, x+2):
    for j in range(y-1, y+2):
      if (i >= 0 and j >= 0) and (i < n and j < m) and arr[i][j] == '*':
        cm += 1
  return cm

n, m = map(int, input().split())
arr = [[0 for i in range(m)] for j in range(n)]
k = int(input())
for l in range(k):
  x, y = map(int, input().split())
  arr[x-1][y-1] = '*'
for i in range(n):
  for j in range(m):
    if arr[i][j] == '*':
      continue
    else:
      arr[i][j] = counter_mines(i, j)
[print(*i) for i in arr]



# JS
// Считываем данные
let z = require('fs').readFileSync(0, 'utf8').split('\n');

let [n, m] = z[0].split(' ').map(Number); // количество строк и столбцов

// Создаём пустое минное поле
let field = [];
for (let i = 0; i < n; i++) {
    let tmp = Array(m).fill(0);
    field.push(tmp);
}

// Расставляем мины
let w = z[1]; // количество мин
for (let wi = 1; wi <= w; wi++) {
    let [y, x] = z[1+wi].split(' ').map(Number);
    field[y-1][x-1] = '*';    
};

// Заполняем поле даннымми о минах
let near = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
for (let y = 0; y < n; y++) {
    for (let x = 0; x < m; x++) {
        if (field[y][x] != '*') {
            let total = 0;
            for (let [yi, xi] of near) {
                [yi, xi] = [y+yi, x+xi];
                if (0 <= yi && yi < n && 0 <= xi && xi < m && field[yi][xi] == '*')
                    total++
            }
            field[y][x] = total;
        }
    } 
}

// Выводим минное поле
for (let row of field)
    console.log(row.join(' '));


# C#
using System;
using System.Collections.Generic;

public class MainClass
{
    public static void Main()
    {
        string[] str = Console.ReadLine().Split();
        int n = Convert.ToInt32(str[0])+2;
        int m = Convert.ToInt32(str[1])+2;
        int[,] arr = new int[n, m];
        int w=int.Parse(Console.ReadLine());
        List<int[]> list = new List<int[]>();
        for (int i = 0; i < w; i++)
        {
            int[] bomb = Array.ConvertAll(Console.ReadLine().Split(),int.Parse);
            int y = bomb[0];
            int x = bomb[1];
            for (int a = y - 1; a < y+2; a++)
            {
                for (int b = x - 1; b < x+2; b++)
                    arr[a, b]++;                
            }
            list.Add(bomb);            
        }
        foreach (int[] item in list)        
            arr[item[0], item[1]] = -1;        

        for (int i = 1; i < n-1; i++)
        {
            for (int j = 1; j < m-1; j++)
            { 
                Console.Write(arr[i, j] == -1 ? "*" : arr[i, j]);
                Console.Write(j == m - 2 ? "" : " ");                
            }
            Console.WriteLine();
        }
    }
}


# java
import java.util.Scanner;
class Main {
    public static void main(String[] args) {
Scanner v=new Scanner(System.in);
int n=v.nextInt(),m=v.nextInt(),k=v.nextInt();
String [][]mina=new String[n][m];   
        
for(int i=0;i<n;i++){
    for(int j=0;j<m;j++){mina[i][j]="0";}}//заполнение нулями
        
for(int i=1,x=0,y=0;i<=k;i++){
x=v.nextInt();y=v.nextInt();    
    for(int j=0;j<n;j++){    
        for(int q=0;q<m;q++){
        if(j==x-1&&q==y-1){mina[j][q]="*";}}}}//заполнение минами

int r1I=0,r2I=0,r1J=0,r2J=0,chet=0,vrem=0;        
for(int i=0;i<n;i++){
    for(int j=0;j<m;j++){
        if(mina[i][j].equals("*")==false){
        r1I=i-1;r2I=i+1;
        if(i-1<0){r1I=i;}
        if(i+1==n){r2I=i;} 
            
        for(;r1I<=r2I;r1I++){//проверка на мины
            r1J=j-1;r2J=j+1;
            if(j-1<0){r1J=j;}  
            if(j+1==m){r2J=j;}
            for(;r1J<=r2J;r1J++){
                if(mina[r1I][r1J].equals("*")==true){chet++;}}}       
        mina[i][j]=""+chet;chet=0;}}}
               
for(int i=0;i<n;i++){
    for(int j=0;j<m;j++){
System.out.print(j==0?mina[i][j]:" "+mina[i][j]);}
System.out.println("");}    //Вывод
    }
}


# C
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

void input_1(size_t* N);
void input_2(size_t* N, size_t* M);
void input_matrix(int64_t*** arr, size_t N, size_t M);
int8_t init_matrix(int64_t*** arr, size_t N, size_t M);
void free_matrix(int64_t*** arr, size_t N);
void echo_matrix(int64_t*** arr, size_t N, size_t M, size_t type);
int64_t get_sum_of_string(int64_t*** arr, size_t i, size_t M);
int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M);
int64_t get_max_in_matrix(int64_t*** arr, size_t N, size_t M);
void fill_matrix(int64_t*** arr, size_t N, size_t M);
void set_bombs(int64_t*** arr, size_t W);
void tag_matrix(int64_t*** arr, size_t N, size_t M);
int64_t identify_danger(int64_t*** arr, size_t N, size_t M, size_t x, size_t y);

int main() {
    size_t N, M, W;
    input_2(&N, &M);
    input_1(&W);
    int64_t** matrix = NULL;
    if (N && M && init_matrix(&matrix, N, M)) {
        fill_matrix(&matrix, N, M);
        set_bombs(&matrix, W); // -1: the bomb
        tag_matrix(&matrix, N, M);
        echo_matrix(&matrix, N, M, 3);
        free_matrix(&matrix, N);
    }
    return 0;
}

int64_t identify_danger(int64_t*** arr, size_t N, size_t M, size_t x, size_t y) {
    int64_t bobms =
(x > 0 && y > 0 && (*arr)[y - 1][x - 1] == -1) +
(y > 0 && (*arr)[y - 1][x] == -1) +
(x + 1 < M && y > 0 && (*arr)[y - 1][x + 1] == -1) +
(x > 0 && (*arr)[y][x - 1] == -1) +
(x + 1 < M && (*arr)[y][x + 1] == -1) +
(x > 0 && y + 1 < N && (*arr)[y + 1][x - 1] == -1) +
(y + 1 < N && (*arr)[y + 1][x] == -1) +
(x + 1 < M && y + 1 < N && (*arr)[y + 1][x + 1] == -1);
    return bobms;
}

void tag_matrix(int64_t*** arr, size_t N, size_t M) {
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            if ((*arr)[i][j] != -1)
                (*arr)[i][j] = identify_danger(&(*arr), N, M, j, i);
}

void set_bombs(int64_t*** arr, size_t W) {
    size_t x, y;
    for (size_t i = 0; i < W; i++) {
        scanf("%zu %zu", &x, &y);
        (*arr)[x - 1][y - 1] = -1;
    }
}

void fill_matrix(int64_t*** arr, size_t N, size_t M) {
for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            (*arr)[i][j] = 0;
}

int64_t get_max_in_matrix(int64_t*** arr, size_t N, size_t M) {
    int64_t max = LLONG_MIN;
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            if ((*arr)[i][j] > max)
                max = (*arr)[i][j];
    return max;
}

int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M) {
    int64_t max = LLONG_MIN;
    for (size_t j = 0; j < M; j++)
        if ((*arr)[i][j] > max)
            max = (*arr)[i][j];
    return max;
}

int64_t get_sum_of_string(int64_t*** arr, size_t i, size_t M) {
    int64_t sum = 0;
    for (size_t j = 0; j < M; j++) sum += (*arr)[i][j];
    return sum;
}

void echo_matrix(int64_t*** arr, size_t N, size_t M, size_t type) {
    for (size_t i = 0; i < N; i++) {
        for (size_t j = 0; j < M; j++) {
            if (type == 1) {
                printf("%"PRId64, (*arr)[i][j]);
                if (j < M - 1) printf(" ");
            } else if (type == 2) {
                printf("%3"PRId64, (*arr)[i][j]);
            } else if (type == 3) {
                if ((*arr)[i][j] == -1) printf("*");
                else printf("%"PRId64, (*arr)[i][j]);
                if (j < M - 1) printf(" ");
            }
            if (j == M - 1) printf("\n");
        }
    }
}

void free_matrix(int64_t*** arr, size_t N) {
    for (size_t i = 0; i < N; i++) free((*arr)[i]);
    free(*arr);
}

int8_t init_matrix(int64_t*** arr, size_t N, size_t M) {
    int8_t result = 0;
    *arr = malloc(N * sizeof(int64_t*));
    if (*arr != NULL) {
        result = 1;
        for (size_t i = 0; i < N; i++) {
            (*arr)[i] = malloc(M * sizeof(int64_t));
            if ((*arr)[i] == NULL) {
                result = 0;
                free_matrix(&(*arr), i);
                break;
            }
        }
    }
    return result;
}

void input_matrix(int64_t*** arr, size_t N, size_t M) {
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            scanf("%"SCNd64, &((*arr)[i][j]));
}

void input_2(size_t* N, size_t* M) {
    int64_t num;
    *N = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
    *M = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
}

void input_1(size_t* N) {
    int64_t num;
    *N = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
}


# C++
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n, m, k, ii, jj;
    cin >> n >> m >> k;
    vector<char> t;
    vector<vector<char> > a;
    for(int i = 0; i < n + 2; ++i){
        t.clear();
        for(int j = 0; j < m + 2; ++j)
            t.push_back('0');
        a.push_back(t);
    }
    for(int i = 0; i < k; ++i){
        cin >> ii >> jj;
        a[ii][jj] = '*';
    }
    for(int i = 1 ; i < a.size() - 1; ++i){
        for(int j = 1; j < a[i].size() - 1; ++j){
            int k = 0;
            if(a[i][j] != '*'){
                if(a[i - 1][j - 1] == '*')
                    ++k;
                if(a[i - 1][j] == '*')
                    ++k;
                if(a[i - 1][j + 1] == '*')
                    ++k;
                if(a[i][j - 1] == '*')
                    ++k;
                if(a[i][j] == '*')
                    ++k;
                if(a[i][j + 1] == '*')
                    ++k;
                if(a[i + 1][j - 1] == '*')
                    ++k;
                if(a[i + 1][j] == '*')
                    ++k;
                if(a[i + 1][j + 1] == '*')
                    ++k;
                if(k != 0)
                    a[i][j] = 48 + k;
            }
        }
    }
        for(int i = 1; i < a.size() - 1; ++i){
        for(int j = 1; j < a[i].size() - 1; ++j)
            
            if (j < a[i].size() - 2)
            {
            	//cout << a[i][j] << " ";  
                cout << setw(2) << left << a[i][j];            
            }
            else
            {
                cout << a[i][j];
            }
        cout << endl;
    }
    return 0;
}

