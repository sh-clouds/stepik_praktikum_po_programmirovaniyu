Переворот

Дан массив N × M. Требуется повернуть его по часовой стрелке на 90 градусов.

Входные данные
На первой строке даны натуральные числа N и M (1 ≤ N, M ≤ 50). На следующих N строках записано по M неотрицательных чисел, не превышающих 109 – сам массив.

Выходные данные
Выведите повернутый массив в формате входных данных.

Sample Input:
3 4
1 2 3 4
5 6 7 8
9 10 11 12

Sample Output:
9 5 1
10 6 2
11 7 3
12 8 4

Напишите программу. Тестируется через stdin → stdout
Верно решили 193 учащихся
Из всех попыток 39% верных


# ruby
n,m = gets.chomp.split(' ').map { |j| j.to_i }
a = []

0.upto(n-1) do |x|   
    a.push(gets.chomp.split(' ').map { |j| j.to_i }) 
end

a = a.transpose

0.upto(m-1) do |i|   
    a[i].reverse!
end

a.each do |i|  
    print i.join(" ")
    print "\n"      
end


# python
n, m = map(int, input().split())
matrix = [input().split() for _ in range(n)]
matrix = [[matrix[~j][i] for j in range(n)] for i in range(m)]
for row in matrix:
    print(*row)



# JS
let arr = require('fs').readFileSync(0, 'utf8').split('\n').slice(1);

arr = arr.map(z => z.split(' '));

const turn = matrix => matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());
const  trarr = turn(arr);

for (let row of trarr)
    console.log(row.join(' '));


# C#
using System;

int[] dimension = Array.ConvertAll(Console.ReadLine().Split(), Convert.ToInt32);        
int rows = dimension[0], cols = dimension[1];

int[,] array = new int[rows, cols];

for (int i = 0; i < rows; i++)
{
    int[] row = Array.ConvertAll(Console.ReadLine().Split(), Convert.ToInt32);
    for (int j = 0; j < cols; j++)
        array[i, j] = row[j];
}

for (int j = 0; j < cols; j++)
    for (int i = rows - 1; i >= 0; i--)
    {
        Console.Write(array[i, j]);
        Console.Write(i > 0 ? " " : "\n");
    }


# java
import java.util.Scanner;
class Main {
    public static void main(String[] args) {
Scanner v = new Scanner(System.in);
int n=v.nextInt(),m=v.nextInt();
int [][]vas=new int[n][m];
for(int i=0;i<n;i++){
    for(int j=0;j<m;j++){
        vas[i][j]=v.nextInt();}}
for(int i=0;i<m;i++){
    for(int j=n-1;j>=0;j--){
        System.out.print(j==0?vas[j][i]:vas[j][i]+" ");}
System.out.println("");}
    }
}


# C
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

void input_1(size_t* N);
void input_2(size_t* N, size_t* M);
void input_matrix(int64_t*** arr, size_t N, size_t M);
int8_t init_matrix(int64_t*** arr, size_t N, size_t M);
void free_matrix(int64_t*** arr, size_t N);
void echo_matrix(int64_t*** arr, size_t N, size_t M, size_t type);
int64_t get_sum_of_string(int64_t*** arr, size_t i, size_t M);
int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M);
int64_t get_max_in_matrix(int64_t*** arr, size_t N, size_t M);
void echo_rotated(int64_t*** arr, size_t N, size_t M);

int main() {
    size_t N, M;
    input_2(&N, &M);
    int64_t** matrix = NULL;
    if (N && M && init_matrix(&matrix, N, M)) {
        input_matrix(&matrix, N, M);
        echo_rotated(&matrix, N, M);
        free_matrix(&matrix, N);
    }
    return 0;
}

void echo_rotated(int64_t*** arr, size_t N, size_t M) {
    for (size_t j = 0; j < M; j++)
        for (size_t i = N; i > 0; i--) {
            printf("%"PRId64, (*arr)[i - 1][j]);
            printf("%s", i == 1 ? "\n" : " ");
        }
}
    
int64_t get_max_in_matrix(int64_t*** arr, size_t N, size_t M) {
    int64_t max = LLONG_MIN;
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            if ((*arr)[i][j] > max)
                max = (*arr)[i][j];
    return max;
}

int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M) {
    int64_t max = LLONG_MIN;
    for (size_t j = 0; j < M; j++)
        if ((*arr)[i][j] > max)
            max = (*arr)[i][j];
    return max;
}

int64_t get_sum_of_string(int64_t*** arr, size_t i, size_t M) {
    int64_t sum = 0;
    for (size_t j = 0; j < M; j++) sum += (*arr)[i][j];
    return sum;
}

void echo_matrix(int64_t*** arr, size_t N, size_t M, size_t type) {
    for (size_t i = 0; i < N; i++) {
        for (size_t j = 0; j < M; j++) {
            if (type == 1) {
                printf("%"PRId64, (*arr)[i][j]);
                if (j < M - 1) printf(" ");
            } else if (type == 2) {
                printf("%3"PRId64, (*arr)[i][j]);
            } else if (type == 3) {
                if ((*arr)[i][j] == -1) printf("*");
                else printf("%"PRId64, (*arr)[i][j]);
                if (j < M - 1) printf(" ");
            }
            if (j == M - 1) printf("\n");
        }
    }
}

void free_matrix(int64_t*** arr, size_t N) {
    for (size_t i = 0; i < N; i++) free((*arr)[i]);
    free(*arr);
}

int8_t init_matrix(int64_t*** arr, size_t N, size_t M) {
    int8_t result = 0;
    *arr = malloc(N * sizeof(int64_t*));
    if (*arr != NULL) {
        result = 1;
        for (size_t i = 0; i < N; i++) {
            (*arr)[i] = malloc(M * sizeof(int64_t));
            if ((*arr)[i] == NULL) {
                result = 0;
                free_matrix(&(*arr), i);
                break;
            }
        }
    }
    return result;
}

void input_matrix(int64_t*** arr, size_t N, size_t M) {
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            scanf("%"SCNd64, &((*arr)[i][j]));
}

void input_2(size_t* N, size_t* M) {
    int64_t num;
    *N = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
    *M = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
}

void input_1(size_t* N) {
    int64_t num;
    *N = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
}



