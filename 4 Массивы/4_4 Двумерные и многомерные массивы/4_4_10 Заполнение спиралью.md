Заполнение спиралью

Дано число n. Создайте массив A[2*n+1][2*n+1] и заполните его по спирали, начиная с числа 0 в центральной клетке A[n+1][n+1]. Спираль выходит вверх, далее закручивается против часовой стрелки.

Входные данные
Программа получает на вход одно число n.

Выходные данные
Программа должна вывести  полученный массив, отводя на вывод каждого числа ровно 3 символа.

Sample Input:
2
Sample Output:

 12 11 10  9 24
 13  2  1  8 23
 14  3  0  7 22
 15  4  5  6 21
 16 17 18 19 20
Напишите программу. Тестируется через stdin → stdout
Верно решили 145 учащихся
Из всех попыток 24% верных


Пример из другого курса
https://stepik.org/lesson/416757/step/10?discussion=4464127&unit=406265

# ruby for other course
n = gets.to_i
i, j = 0, 0
a = []

0.upto(2*n) do |i|
    a.push([])
end

0.upto(2*n) do |i|
    0.upto(2*n) do |j|
        a[i].push(-1)
    end    
end

d = 0
nk = 2

0.upto (nk-1) do |k|
    i = k
    k.upto(2*n-1-k) do |j| #TOP
        d += 1
        a[i][j] = d
    end

    j = 2*n-k
    k.upto(2*n-1-k) do |i| #RIGHT
        d += 1
        a[i][j] = d 
    end    

    i = 2*n-k
    k.upto(2*n-1-k) do |j| #BOTTOM
        d += 1
        a[i][2*n-j] = d    
    end

    j = k
    k.upto(2*n-1-k) do |i| #LEFT
        d += 1
       a[2*n-i][j] = d    
    end
end

d += 1
a[n][n] = d

a.each do |i|
    puts i.join(" ")
end  


# ruby
n = gets.to_i
a = []

0.upto(2*n) do |i|
    a.push([])
end

0.upto(2*n) do |i|
    0.upto(2*n) do |j|
        a[i].push(-1)
    end    
end

d = (2*n+1)*(2*n+1)
nk = n

0.upto (nk-1) do |k|
    j = 2*n-k
    k.upto(2*n-1-k) do |i| #RIGHT
        d -= 1
        a[i][j] = d 
    end  
    
    i = 2*n-k
    k.upto(2*n-1-k) do |j| #BOTTOM
        d -= 1
        a[i][2*n-j] = d    
    end  
    
    j = k
    k.upto(2*n-1-k) do |i| #LEFT
        d -= 1
       a[2*n-i][j] = d    
    end   
    
    i = k
    k.upto(2*n-1-k) do |j| #TOP
        d -= 1
        a[i][j] = d
    end
end

d -= 1
a[n][n] = d

a.each do |i|
    i.each do |j|
        if j<10
            print "  #{j}"
        elsif j<100
            print " #{j}" 
        else    
            print "#{j}" 
        end    
    end
    print "\n"      
end 


# python
# Импорт библиотеки numpy для работы с матрицами.
import numpy as np

# Из библиотеки itertools импортируем итератор count.
from itertools import count

# Из библиотеки math импортируем функцию округления в большую сторону.
from math import ceil

# Считываем входящее число и задаем размерность матрицы.
n = m = 2 * int(input()) + 1

# Задаем начальное значение итератора - максимальное число в последовательности чисел
# и шаг итератора - минус один.
count_n = count(start=n * m - 1, step=-1)

# Создаем входящую матрицу, заполненную значением -1.
matrix = np.full((n, m), -1)

# В цикле проходим от 0 до половины от наименьшей стороны матрицы
# (округление в большую сторону).
for i in range(ceil(min(n, m) / 2)):

    # Для первоначальной матрицы.
    # Создаем маску для i-ой строки, если элемент = -1, то True, иначе False.
    mask = matrix[i] == -1
    # Производим замену в i-й строке по маске на последовательные числа из итератора.
    np.place(matrix[i], mask, [next(count_n) for _ in range(np.sum(mask))])

    # Матрицу повернули на 90 градусов против часовой стрелки.
    # Создаем маску для i-ой сверху строки. Если элемент = -1, то True, иначе False.
    mask = np.rot90(matrix)[i] == -1
    # Меняем значения в i-й сверху строке по маске на последовательные числа из итератора.
    np.place(np.rot90(matrix)[i], mask, [next(count_n) for _ in range(np.sum(mask))])

    # Ещё раз повернули на 90 градусов.
    # Создаем маску для i-ой сверху строки. Если элемент = -1, то True, иначе False.
    mask = np.rot90(np.rot90(matrix))[i] == -1
    # Меняем значения в i-й сверху строке по маске на последовательные числа из итератора.
    np.place(np.rot90(np.rot90(matrix))[i], mask, [next(count_n) for _ in range(np.sum(mask))])

    # И ещё раз повернули на 90 градусов.
    # Создаем маску для i-ой сверху строки. Если элемент = -1, то True, иначе False.
    mask = np.rot90(np.rot90(np.rot90(matrix)))[i] == -1
    # Меняем значения в i-й сверху строке по маске на последовательные числа из итератора.
    np.place(np.rot90(np.rot90(np.rot90(matrix)))[i], mask, [next(count_n) for _ in range(np.sum(mask))])

# Вывод результатов.
print(*[''.join(['{:>3d}'.format(el) for el in row.tolist()])
        for row in np.rot90(np.rot90(np.rot90(matrix)))], sep='\n')



# C#
using System;

public class MainClass
{
    public static void Main()
    {
        int n=int. Parse(Console.ReadLine());
        int len=n*2+1;
        int[,] arr=new int[len, len]; 
        int lastNumber=arr.Length; 
        int y=n, x=n, i=1, steps, path=1;    
         for(;i<lastNumber;path++) 
         {               
        for(steps=path;i<lastNumber && steps !=0;i++, steps--)
         {
            arr[--y,x]=i;          
         }
         for(steps=path;i<lastNumber && steps !=0;i++, steps--)
         {
         arr[y,--x]=i;
         }
         path++;
         for(steps=path;i<lastNumber && steps >0;i++, steps--)
         {
         arr[++y,x]=i;
         }
         for(steps=path;i<lastNumber && steps >0;i++, steps--)
         {
         arr[y,++x]=i;
         }
         }
         //Print:
        for(int a=0;a<len;a++)
        {
            for(int b=0;b<len;b++)            Console.Write($"{arr[a,b]}".PadLeft(3));
            Console.WriteLine();
        }
    }
}


# java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int number = Integer.parseInt(input.nextLine());

        int[][] matrix = new int[2 * number + 1][2 * number + 1];
        String direction = "left";
        int count = 2, counter = 0, row = matrix.length / 2 - 1, column = matrix[0].length / 2;

        for (int a = 1; a < Math.pow(2 * number + 1, 2); a++) {
            if(direction.equals("left") && counter < count) {
                if(counter != 0) column -= 1;
                matrix[row][column] = a;
                ++counter;
                if(counter == count) {
                    direction = "down";
                    counter = 0;
                }
            }
            else if(direction.equals("down") && counter < count) {
                row += 1;
                matrix[row][column] = a;
                ++counter;
                if(counter == count) {
                    direction = "right";
                    counter = 0;
                }
            }
            else if(direction.equals("right") && counter < count) {
                column += 1;
                matrix[row][column] = a;
                ++counter;
                if(counter == count) {
                    direction = "up";
                    counter = 0;
                }
            }
            else if(direction.equals("up") && counter < count) {
                row -= 1;
                matrix[row][column] = a;
                ++counter;
                if(counter == count) {
                    direction = "left";
                    counter = 0;
                    count += 2;
                    row -= 1;
                }
            }
        }

        for (int a = 0; a < matrix.length; a++) {
            for (int b = 0; b < matrix[a].length; b++) {
                if(b < matrix[a].length - 1) System.out.printf("%3d", matrix[a][b]);
                else System.out.printf("%3d%n", matrix[a][b]);
            }
        }
    }
}


# C 
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

void input_n(size_t* N);
void input_n_m(size_t* N, size_t* M);
int8_t init_matrix(int64_t*** arr, size_t N, size_t M);
void input_matrix(int64_t*** arr, size_t N, size_t M);
void free_matrix(int64_t*** arr, size_t N);
void echo_matrix(int64_t*** arr, size_t N, size_t M, size_t type);
int64_t get_sum_of_string(int64_t*** arr, size_t i, size_t M);
int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M);
int64_t get_max_in_matrix(int64_t*** arr, size_t N, size_t M);
void fill_matrix(int64_t*** arr, size_t N, size_t M);

int main() {
    size_t N, M;
    input_n(&N);
    N = M = 2 * N + 1;
    int64_t** matrix = NULL;
    if (N && M && init_matrix(&matrix, N, M)) {
        fill_matrix(&matrix, N, M);
        echo_matrix(&matrix, N, M, 2);
        free_matrix(&matrix, N);
    }
    return 0;
}

void fill_matrix(int64_t*** arr, size_t N, size_t M) {
    size_t ci, cj;
    ci = cj = (((N - 1) / 2) + 1) - 1;
    int64_t item = 0, fill = 1, way = 1, step = 1;
// way = 1: -Y, 2: -X, 3: +Y, 4: +X; 0 - stop
// step++: 2 > 3 & 4 -> 1
    (*arr)[ci][cj] = item++;
    while (fill) {
        if (way == 1) {
            way = 2;
            for (size_t i = 1; i <= step; i++) {
                if (i > ci) way = 0;
                else (*arr)[ci - i][cj] = item++;
            }
            ci -= step;
        } else if (way == 2) {
            way = 3;
            for (size_t i = 1; i <= step; i++) {
                if (i > cj) way = 0;
                else (*arr)[ci][cj - i] = item++;
            }
            cj -= step;
            step++;
        } else if (way == 3) {
            way = 4;
            for (size_t i = 1; i <= step; i++) {
                if (ci + i > N) way = 0;
                else (*arr)[ci + i][cj] = item++;
            }
            ci += step;
        } else if (way == 4) {
            way = 1;
            for (size_t i = 1; i <= step; i++) {
                if (cj + i > M) way = 0;
                else (*arr)[ci][cj + i] = item++;
            }
            cj += step;
            step++;
        } else {
            fill = 0;
        }
    }
}

int64_t get_max_in_matrix(int64_t*** arr, size_t N, size_t M) {
    int64_t max = LLONG_MIN;
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            if ((*arr)[i][j] > max)
                max = (*arr)[i][j];
    return max;
}

int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M) {
    int64_t max = LLONG_MIN;
    for (size_t j = 0; j < M; j++)
        if ((*arr)[i][j] > max)
            max = (*arr)[i][j];
    return max;
}

int64_t get_sum_of_string(int64_t*** arr, size_t i, size_t M) {
    int64_t sum = 0;
    for (size_t j = 0; j < M; j++) sum += (*arr)[i][j];
    return sum;
}

void echo_matrix(int64_t*** arr, size_t N, size_t M, size_t type) {
    for (size_t i = 0; i < N; i++) {
        for (size_t j = 0; j < M; j++) {
            if (type == 1) {
                printf("%"PRId64, (*arr)[i][j]);
                if (j < M - 1) printf(" ");
            } else if (type == 2) {
                printf("%3"PRId64, (*arr)[i][j]);
            }
            if (j == M - 1) printf("\n");
        }
    }
}

void free_matrix(int64_t*** arr, size_t N) {
    for (size_t i = 0; i < N; i++) free((*arr)[i]);
    free(*arr);
}

void input_matrix(int64_t*** arr, size_t N, size_t M) {
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            scanf("%"SCNd64, &((*arr)[i][j]));
}

int8_t init_matrix(int64_t*** arr, size_t N, size_t M) {
    int8_t result = 0;
    *arr = malloc(N * sizeof(int64_t*));
    if (*arr != NULL) {
        result = 1;
        for (size_t i = 0; i < N; i++) {
            (*arr)[i] = malloc(M * sizeof(int64_t));
            if ((*arr)[i] == NULL) {
                result = 0;
                free_matrix(&(*arr), i);
                break;
            }
        }
    }
    return result;
}

void input_n_m(size_t* N, size_t* M) {
    int64_t num;
    *N = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
    *M = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
}

void input_n(size_t* N) {
    int64_t num;
    *N = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
}



# java

