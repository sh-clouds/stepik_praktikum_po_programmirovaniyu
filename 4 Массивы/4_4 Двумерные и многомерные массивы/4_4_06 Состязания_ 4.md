Состязания - 4

В метании молота состязается n спортcменов. Каждый из них сделал mбросков. Победитель определяется по лучшему результату. Определите количество участников состязаний, которые разделили первое место, то есть определите количество строк в массиве, которые содержат значение, равное наибольшему.

Входные данные
Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве. Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.

Выходные данные
Программа должна вывести  одно число - количество победителей соревнования.

Sample Input:
3 3
3 1 2
1 3 4
3 3 3

Sample Output:
1

Напишите программу. Тестируется через stdin → stdout
Верно решили 289 учащихся
Из всех попыток 59% верных


# ruby
n,m = gets.chomp.split(' ').map { |j| j.to_i }
a = []
max, cnt_max = 0, 0

0.upto(n-1) do |x|   
    a.push(gets.chomp.split(' ').map { |j| j.to_i }) 
end

0.upto(n-1) do |x|	# max result
    max_try = a[x].max
    if max < max_try
        max = max_try     
    end   
end

0.upto(n-1) do |x|	# count sportsmen
    if max == a[x].max
        cnt_max += 1    
    end   
end

print cnt_max


# python
n, m = map(int, input().split())
mas = [list(map(int, input().split())) for _ in range(n)]
win = max(max(mas, key=max))
print(sum(win in i for i in mas))


# JS
let arr = require('fs').readFileSync(0, 'utf8').split('\n').slice(1)

arr = arr.map(function (row) {
    return row.split(' ').map(Number)
})

let maxInRow = arr.map(function (row) {
    return Math.max(...row)
})

let bestResult = Math.max(...maxInRow)

let bestPlayers = arr.filter(function (player) {
    return player.includes(bestResult)
})

console.log(bestPlayers.length)


# C#
# using System;
using System.Linq;

public class MainClass
{
    public static void Main()
    {
        int[] nm = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);
        int n = nm[0];
        int m = nm[1];
        int[,] arr = new int[n, m];
        for (int i = 0; i < n; i++)
        {
            int[] tmp = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);
            for (int j = 0; j < m; j++)
            {
                arr[i, j] = tmp[j];
            }
        }

        int[] temp=new int[m];
        int count = 0;
        int max=0;
        for (int i=0;i<n;i++) 
        {
            for (int j = 0; j < m; j++)
            {
                temp[j] = arr[i, j];
            }
            if (temp.Max() > max)
            {
                count=1;
                max = temp.Max();
            }
            else if (temp.Max() == max)
            {
                count++;
            }
            
        }
        Console.WriteLine(count);
    }
}


# java
import java.util.Scanner;
class Main {
    public static void main(String[] args) {
Scanner v = new Scanner(System.in);
int n=v.nextInt(),m=v.nextInt(),strong=0,col=1;
int vas[][]=new int[n][m];        
for(int i=0,chet=0;i<n;i++){
    for(int j=0;j<m;j++){
        vas[i][j]=v.nextInt();
        if(chet<vas[i][j]){chet=vas[i][j];}}
if(strong==chet){col++;}    
if(strong<chet){strong=chet;col=1;}
chet=0;}
System.out.println(col);        
    }
}


# C 
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

void input_count(size_t* N, size_t* M);
int8_t init_matrix(int64_t*** arr, size_t N, size_t M);
void input_matrix(int64_t*** arr, size_t N, size_t M);
void free_matrix(int64_t*** arr, size_t N);
void echo_matrix(int64_t*** arr, size_t N, size_t M);
int64_t get_sum_string(int64_t*** arr, size_t i, size_t M);
int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M);
void echo_count_max(int64_t*** arr, size_t N, size_t M);

int main() {
    size_t N, M;
    input_count(&N, &M);
    int64_t** matrix = NULL;
    if (N && M && init_matrix(&matrix, N, M)) {
        input_matrix(&matrix, N, M);
        echo_count_max(&matrix, N, M);
        free_matrix(&matrix, N);
    }
    return 0;
}

void echo_count_max(int64_t*** arr, size_t N, size_t M) {
    size_t count = 0;
    int64_t max = LLONG_MIN, cur = LLONG_MIN;
    for (size_t i = 0; i < N; i++) {
        cur =  get_max_in_string(&(*arr), i, M);
        if (cur > max) {
            max = cur;
            count = 1;
        } else if (cur == max) {
            count++;
        }
    }
    printf("%zu", count);
}

int64_t get_max_in_string(int64_t*** arr, size_t i, size_t M) {
    int64_t max = LLONG_MIN;
    for (size_t j = 0; j < M; j++)
        if ((*arr)[i][j] > max)
            max = (*arr)[i][j];
    return max;
}

int64_t get_sum_string(int64_t*** arr, size_t i, size_t M) {
    int64_t sum = 0;
    for (size_t j = 0; j < M; j++) sum += (*arr)[i][j];
    return sum;
}

void echo_matrix(int64_t*** arr, size_t N, size_t M) {
    for (size_t i = 0; i < N; i++) {
        for (size_t j = 0; j < M; j++) {
            printf("%"PRId64, (*arr)[i][j]);
            printf("%s", j < M - 1 ? " " : "\n");
        }
    }
}

void free_matrix(int64_t*** arr, size_t N) {
    for (size_t i = 0; i < N; i++) free((*arr)[i]);
    free(*arr);
}

void input_matrix(int64_t*** arr, size_t N, size_t M) {
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < M; j++)
            scanf("%"SCNd64, &((*arr)[i][j]));
}

int8_t init_matrix(int64_t*** arr, size_t N, size_t M) {
    int8_t result = 0;
    *arr = malloc(N * sizeof(int64_t*));
    if (*arr != NULL) {
        result = 1;
        for (size_t i = 0; i < N; i++) {
            (*arr)[i] = malloc(M * sizeof(int64_t));
            if ((*arr)[i] == NULL) {
                result = 0;
                free_matrix(&(*arr), i);
                break;
            }
        }
    }
    return result;
}

void input_count(size_t* N, size_t* M) {
    int64_t num;
    *N = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
    *M = (scanf("%zu", &num) == 1 && num > 0) ? num : 0;
}



